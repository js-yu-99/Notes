HTTP(HyperText Transfer Protocol，超文本传输协议)

1989 年，任职于欧洲核子研究中心（CERN）的蒂姆·伯纳斯 - 李（Tim Berners-Lee）发表了一篇论文，提出了在互联网上构建超链接文档系统的构想。这篇论文中他确立了三项关键技术。

- URI：即统一资源标识符，作为互联网上资源的唯一身份；
- HTML：即超文本标记语言，描述超文本文档；

- HTTP：即超文本传输协议，用来传输超文本。



## HTTP版本：

- HTTP/0.9：是个简单的文本协议，只能获取文本资源；
- HTTP/1.0：确立了大部分现在使用的技术，但它不是正式标准；

- - 增加了 HEAD、POST 等新方法；
  - 增加了响应状态码，标记可能的错误原因；

- - 引入了协议版本号概念；
  - 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；

- - 传输的数据不再仅限于文本；

- HTTP/1.1：是目前互联网上使用最广泛的协议，功能也非常完善；

- - 增加了 PUT、DELETE 等新的方法；
  - 增加了缓存管理和控制；

- - 明确了连接管理，允许持久连接；
  - 允许响应数据分块（chunked），利于传输大文件；强制要求 Host 头，让互联网主机托管成为可能；

- HTTP/2.0：基于 Google 的 SPDY 协议，注重性能改善，但还未普及；

- - 二进制协议，不再是纯文本；
  - 可发起多个请求，废弃了 1.1 里的管道

- - ；使用专用算法压缩头部，减少数据传输量；
  - 允许服务器主动向客户端推送数据；

- - 增强了安全性，“事实上”要求加密通信；

- HTTP/3：基于 Google 的 QUIC 协议，是将来的发展方向。



## HTTP是什么？

- 协议：有两个或者多个参与者、对参与者的一种行为约定和规范

- - ***HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。***

- 传输：A <===> B  双向协议，A、B之间可以存在中转和接力

- - ***HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。\***

- 超文本：“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。

- - ***HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范***

## HTTP不是什么？

- HTTP 不是互联网
- HTTP 不是编程语言

- HTTP 不是 HTML
- HTTP 不是一个孤立的协议

- - 在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1634030747817-10cff3b4-5dc4-4d4d-b830-b29c53cbfabe.png)

- 你觉得 CDN 在对待浏览器和爬虫时会有差异吗？为什么？

- - **不会，当爬虫的浏览器都使用一样的useragent时，cdn并不能识别**

- 你怎么理解 WebService 与 Web Server 这两个非常相似的词？

- - **web server就是提供http服务的server、web service就是运行在http协议上的服务接口规范。**



IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。

TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。



## TCP/IP网络分层模型

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1634120348637-dc9777d5-7fc7-4b31-83ac-0eabca0c868d.png)

TCP/IP 协议总共有四层，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。

- **数据链路层（数据链路层，网络接口层）**

- - 负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

- **网络层（网络互连层）**

- - IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。

- **传输层**

- - TCP（传输控制协议）、UDP（用户数据报协议）
  - 这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。

- **应用层**

- - 应用层决定了向用户提供应用服务时通信的活动。
  - TCP/IP提供了各类服务协议：FTP、DNS、HTTP等协议



### TCP/IP 协议栈的工作方式

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1631015578265-5191f5aa-d339-458f-8a4f-98cfd55952b0.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1634135604741-69627296-9a46-4c94-9c69-230eb7749ae6.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1631016144379-3e5db1eb-f7db-494b-a0d8-83ef77353461.png)

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。返回，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为**封装（encapsulate）**



## OSI 网络分层模型

OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。

OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1634135155466-5ba58b16-acbd-472b-9658-8e11eef1dd0b.png)

1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
2. 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
3. 第三层：网络层，相当于 TCP/IP 里的网络层；
4. 第四层：传输层，相当于 TCP/IP 里的传输层；
5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步；
6. 第六层：表示层，把数据转换为合适、可理解的语法和语义；
7. 第七层：应用层，面向具体的应用传输数据。

### TCP/IP与OSI模型的对应关系

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1634135250001-98202a62-af71-4326-a901-45ca0f2b58d0.png)

1. 第一层：物理层，TCP/IP 里无对应；
2. 第二层：数据链路层，对应 TCP/IP 的链接层；
3. 第三层：网络层，对应 TCP/IP 的网际层；
4. 第四层：传输层，对应 TCP/IP 的传输层；
5. 第五、六、七层：统一对应到 TCP/IP 的应用层。

所谓的“**四层负载均衡**”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。

所谓的“**七层负载均衡**”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。

“两个凡是”：凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。



**你能用自己的话解释一下“二层转发”“三层路由”吗？**

- 二层转发：二层应该指数据链路层，工作在二层的设备，通过查找到目标MAC地址，进行数据转发
- 三层路由：三层应该指网络层，工作在三层的设备，通过解析数据包头信息，找到目标IP地址，转发数据

**你认为上一讲中的 DNS 协议位于哪一层呢？**

+ 应用层

**你认为 CDN 工作在那一层呢？**

+ 应用层



## 与HTTP相关的协议：IP、TCP、DNS

#### 负责传输的IP协议

- IP(Internet Protocol)网络协议位于网络层。
- IP地址的作用是把各种数据包传送给对方（主要两个传送条件是IP地址和MAC地址）。

- IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。
- IP间的通信依赖MAC地址。在进行中转发送时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会通过ARP协议（Address Resolution Protocol  -- 地址解析协议）。根据通信方的IP地址反查对应的MAC地址。

#### 确保可靠性的TCP协议

- TCP位于传输层，提供可靠的字节流服务
- 字节流服务是指为了方便传输将大块数据分割成以报文段为单位的数据包进行管理。

- 三次握手

- - 第一次握手：发送端首先发送一个带SYN标志的数据包给对方。（此次握手可以理解为发送端在进行发送端发送能力和接收端接收能力的测试。）
  - 第二次握手：接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认的信息。（此次握手接收端确认了发送端的发送能力以及接收端的接收能力。并且再次进行接收端发送能力和发送端接收能力的测试。）

- - 第三次握手：发送端再回传一个带ACK标志的数据包，代表“握手”结束。（此次握手发送端确认接收端的发送能力和发送端的接受能力。并继续进行接收端发送能力的测试。当接收端收到发送端再次发送的内容，证明发送端和接收端接收发送能力都正常，可以建立链接进行数据传输。）

#### 负责域名解析的DNS服务

- DNS服务时和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。



## 域名

### 域名的形式

域名是一个有层次的结构，是一串用“.”分割的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。最左边是主机名，通常用来表明主机的用户。

`www.baidu.com `域名中， `com`是顶级域名，`baidu`是二级域名，`www`是主机名。

域名本质上是类似namespace的命名空间系统，使用多级域名就可以划分出不同的国家、地区、组织、公司等，每个域名都是独一无二的。

### 域名的解析

DNS的核心系统是一个三层的树状、分布式服务，基于对应域名的结构

- `根域名服务器`：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；
- `顶级域名服务器`：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 .com 域名服务器的 IP 地址；

- `权威域名服务器`：管理自己域名下主机的 IP 地址，比如 baidu.com 权威域名服务器可以返回 www.baidu.com 的 IP 地址。

在这里根域名服务器是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。

有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，最终就获得了域名对应的 IP 地址。

例如，访问“www..com”，就要进行下面的三次查询：访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；访问“com”顶级域名服务器，它再告诉你“baidu.com”域名服务器的地址；最后访问“baidu.com”域名服务器，就得到了“www.baidu.com”的地址。

### DNS缓存

为了减少域名解析的压力，提供了多种基于缓存的手段。

1. 许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。
2. 操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“www.baidu.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。



## URI和URL

### 统一资源标识符URI

Uniform Resource Identifier

URI是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。

URI用字符串标识某一互联网资源，而URL表示资源的地点。URL是URI的子集。

### URI格式

- 登录信息（认证）
- 服务器地址

- 服务器端口号
- 带层次的文件路径

- 查询字符串
- 片段标识符



# 简单的HTTP协议

+ P协议用户客户端和服务器端之间通信

+ 通过请求和响应的交换达成通信

+ HTTP是无状态的协议

+ 使用URI定位互联网上的资源

+ 告知服务器意图的HTTP方法

1. + GET：获取资源

2. + POST：传输实体主体

1. + PUT：传输文件（但是因为http1.1的put方法不带验证机制，所以存在安全性问题）

2. + HEAD：获取报文首部（用于确定URI的有效性及资源更新的日期时间等）

1. + DELETE：删除文件（同样http1.1中delete方法不带验证机制，存在安全性问题）

2. + OPTIONS：查询针对请求URI指定的资源支持的方法

1. + TRACE：追踪路径（让web服务器将之前的请求通信环回给客户端）

1. 1. 1. 不常用，并且容易引起XST（跨站追踪）攻击，通常就更不会用到了

1. + CONNECT：要求用隧道协议连接代理

1. 1. 1. 主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输

+ 持久连接节省通信量

+ + keep-alive

+ 管线化

1. + 不必顶导发送请求后需等待并收到响应，才能发送下一个请求

+ 使用Cookie的状态管理

1. + Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

2. + 服务端发送一个Set-Cookie的首部字段信息，通知客户端保存Cookie。

# HTTP报文中的HTTP信息

用于HTTP协议交互的信息被称为HTTP报文。客户端的HTTP报文叫做请求报文，服务端的叫做响应报文。HTTP报文本身是由多行（用CR + LF作换行符）数据构成的字符串文本。

HTTP报文大致分为报文首部和报文主体两块（CR+LF空行划分）。

## 报文首部组成

- **请求行**：包含用于请求的方法，请求URI和HTTP版本。
- **状态行**：包含辨明响应结果的状态码、原因短语和HTTP版本。

- **首部字段**：包含表示请求和响应的各种条件和属性的各类首部（通用首部、请求首部、响应首部、实体首部）。
- **其他**：可能包含HTTP的RFC里未定义的首部（Cookie等）。



------

# HTTP报文

HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

- 起始行（start line）：描述请求或响应的基本信息；
- 头部字段集合（header）：使用 key-value 形式更详细地说明报文；

- 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。



这其中前两部分起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接称为“body”。HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1636978843870-3a8f3ccd-56f8-4f9f-8779-65a920c91e87.png)



## 请求行



- 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
- 请求目标：通常是一个 URI，标记了请求方法要操作的资源；

- 版本号：表示报文使用的 HTTP 协议版本。这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1636978928268-57e990ad-be6e-4b48-ba7b-ca6bbde621bd.png)



## 状态行 / 响应行



- 版本号：表示报文使用的 HTTP 协议版本；
- 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；

- 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1636979034369-046b46c6-5e9e-4c4a-9071-7615f6daa6cb.png)



## 头部字段

HTTP 头字段非常灵活，不仅可以使用标准里的 Host、Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。



使用时注意事项

- 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；
- 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；

- 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；
- 字段的顺序是没有意义的，可以任意排列不影响语义；

- 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。



常见的字段：

Host：告诉服务器这个请求应该由哪个主机来处理。必须加上的字段，如果缺少则会成为错误报文。

User-Agent：请求头字段，表示浏览器信息。

Date：通用字段，报文创建时间。可以根据这个字段制定缓存策略

Server：响应字段，告知客户端服务器的软件名称和版本号



# URI / URL

URI，统一资源标识符（Uniform Resource Identifier）, 包含有 URL 和 URN 两个部分，在 HTTP 世界里用的网址实际上是 URL——统一资源定位符（Uniform Resource Locator）。但因为 URL 实在是太普及了，所以常常把这两者简单地视为相等。



URI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637067731450-07e574a2-21c8-4347-9b35-7caf848eeca8.png)

- URI 第一个组成部分叫 scheme，翻译成中文叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。在 scheme 之后，必须是三个特定的字符“://”，它把 scheme 和后面的部分分离开。

- 身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。

- 在“://”之后，是被称为“authority”的部分，表示资源所在的主机名，通常的形式是“host:port”，即主机名加端口号。主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。
- 有了协议名和主机地址、端口号，再加上后面标记资源所在位置的 path，浏览器就可以连接服务器访问资源了。URI 的 path 部分必须以“/”开始，也就是必须包含“/”

- 查询参数 query 有一套自己的格式，是多个“key=value”的字符串，这些 KV 值用字符“&”连接，浏览器和服务器都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。

- 片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。



在 URI 里只能使用 ASCII 码，但如果要在 URI 里使用英语以外的汉语、日语等其他语言该怎么办？

URI 引入了编码机制，对于 ASCII 码以外的字符集和特殊字符做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。

URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。例如，空格被转义成“%20”，“?”被转义成“%3F”。而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。



---



# 面试题



## 1.用户输入url点击回车到页面渲染完成中间发生了什么？



### 1）构建出http协议信息



### 2）查找HTTP资源缓存



### 3）DNS解析



由于我们输入的是域名，而数据包是通过`IP地址`传给对方的。因此我们需要得到域名对应的`IP地址`。这个过程需要依赖一个服务系统，这个系统将域名和 IP 一一映射，我们将这个系统就叫做**DNS**（域名系统）。得到具体 IP 的过程就是`DNS`解析。



当然，值得注意的是，浏览器提供了**DNS数据缓存功能**。即如果一个域名已经解析过，那会把解析的结果缓存下来，下次处理直接走缓存，不需要经过 `DNS解析`。



解析包括操作系统、本地 DNS（浏览器、本地host文件）、根 DNS、顶级 DNS、权威 DNS 的层层解析



操作系统和本地DNS会存有本机访问过的域名和ip的缓存



信息被缓存后,原本的注册信息可能会发生改变,这时缓存中的信息就有可能是不正确的，因此缓存信息会设置有效期，当缓存中的信息超过有效期后,数据就会从缓存中删除。



另外，如果不指定端口的话，默认采用对应的 IP 的 80 端口。



***域名和 IP 地址并用的理由***



- 不用IP 地址，而是用名称来确定通信对象?
  IP 地址的长度 为 32 比特（ 4 字节），使用域名最少也要几十个字节，最长可达到255字节，增加了路由器的负担,传送数据也会花费更长的时间 ，运行效率较低。（路由转发包传输数据）
- 浏览器网址中不写服务器的名字，直接写IP 地址?
  用IP地址来代替服务器名称也是能够正常工作的 。然而,要记住一串由数字组成的 IP 地址也非常困难

- 让人来使用名称,让路由器来使用IP地址。
  为了填补两者之间的障碍,需要有一个机制能够通过名称来查询IP地址,或者通过IP 地址来查询名称,这个机制就是DNS



### 4）建立TCP连接



**Chrome 在同一个域名下要求同时最多只能有 6 个 TCP 连接，超过 6 个的话剩下的请求就得等待**



TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。



建立 `TCP连接`经历了下面三个阶段:



1. 通过**三次握手**(即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。
2. 进行数据传输。接收方接收到数据包后必须要向发送方`确认`, 如果发送方没有接到这个`确认`的消息，就判定为数据包丢失，并重新发送该数据包。当然，发送的过程中还有一个优化策略，就是把`大的数据包拆成一个个小包`，依次传输到接收方，接收方按照这个小包的顺序把它们`组装`成完整数据包。

1. 断开连接的阶段。数据传输完成，现在要断开连接了，通过**四次挥手**来断开连接。



#### 三次握手



三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。



刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。



进行三次握手：



第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN©。此时客户端处于 SYN_SEND 状态。



首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。



第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。



在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。



第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。



确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。



发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。



#### 为什么连接的时候是三次握手？



如果是三次握手



**第一次握手：客户端发送网络包，服务端收到了。**



这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。



**第二次握手：服务端发包，客户端收到了。**



这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。



**第三次握手：客户端发包，服务端收到了。**



这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。



因此，需要三次握手才能确认双方的接收与发送能力是否正常。



如果是用两次握手，则会出现下面这种情况：



如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1636797618928-2dcf86e6-74bb-4dc1-89e5-8d81d0a6606c.png)



### 5）发送 HTTP 请求



浏览器发送 HTTP 请求要携带三样东西:**请求行**、**请求头**和**请求体**。



网络响应具有三个部分:**响应行**、**响应头**和**响应体**。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1636797527041-da34b30f-74f3-4638-8fb3-9f3c80b9c43a.png)



### 6）浏览器解析

#### 构建 DOM 树

由于浏览器无法直接理解HTML字符串，因此将这一系列的字节流转换为一种有意义并且方便操作的数据结构，这种数据结构就是DOM树。DOM树本质上是一个以document为根节点的多叉树。

#### 样式计算

关于CSS样式，它的来源一般是三种:

1. **link标签引用**
2. **style标签中的样式**

1. **元素的内嵌style属性**

首先，浏览器是无法直接识别 CSS 样式文本的，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即styleSheets。

有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如em->px,red->#ff0000,bold->700等等。



样式已经被格式化和标准化,接下来就可以计算每个节点的具体样式信息了。

计算的方式两个规则: **继承**和**层叠**。

每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式。这就是继承规则，非常容易理解。

然后是层叠规则，CSS 最大的特点在于它的层叠性，也就是最终的样式取决于各个属性共同作用的效果，甚至有很多诡异的层叠现象。

不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到window.getComputedStyle当中，也就是可以通过JS来获取计算后的样式，非常方便。



现在已经生成了DOM树和DOM样式，接下来要做的就是通过浏览器的布局系统确定元素的位置，也就是要生成一棵布局树(Layout Tree)。

布局树生成的大致工作如下:

1. 遍历生成的 DOM 树节点，并把他们添加到布局树中。
2. 计算布局树节点的坐标位置。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1636797952436-3a3e26df-6a0e-410d-b1b6-f82625938df5.png)

### 7）浏览器渲染

- 建立图层树(Layer Tree)
- 生成绘制列表

- 生成图块并栅格化
- 显示器显示内容



#### 建立图层树(Layer Tree)

为了考虑到动画等复杂场景，浏览器在构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树(Layer Tree)。

一般情况下，节点的图层会默认属于父亲节点的图层(这些图层也称为**合成层**)。

有两种情况需要分别讨论，一种是**显式合成**，一种是**隐式合成**。

**显式合成**

下面是显式合成的情况:

一、 拥有**层叠上下文**的节点。

层叠上下文也基本上是有一些特定的CSS属性创建的，一般有以下情况:

1. HTML根元素本身就具有层叠上下文。
2. 普通元素设置**position不为static**并且**设置了z-index属性**，会产生层叠上下文。

1. 元素的 **opacity** 值不是 1
2. 元素的 **transform** 值不是 none

1. 元素的 **filter** 值不是 none
2. 元素的 **isolation** 值是isolate

1. **will-change**指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)

二、需要**剪裁**的地方。

比如一个div，你只给他设置 100 * 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。

**隐式合成**

接下来是隐式合成，简单来说就是层叠等级低的节点被提升为单独的图层之后，那么所有层叠等级比它高的节点**都会**成为一个单独的图层。

这个隐式合成其实隐藏着巨大的风险，如果在一个大型应用中，当一个z-index比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是**层爆炸**的原理。



#### 生成绘制列表

接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按顺序组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。



#### 生成图块并栅格化

绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。

首先，考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将图层**分块**。这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。

因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个**低分辨率**的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。

顺便提醒一点，渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块**转换为**位图数据**。

然后合成线程会选择视口附近的**图块**，把它交给**栅格化线程池**生成位图。

生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程。



#### 显示器显示内容

栅格化操作完成后，**合成线程**会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。

浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。

无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的**前缓冲区**。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。

当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1636798614613-16ee8118-50a5-4428-b227-6afb20fd89e7.png)


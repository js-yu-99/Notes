# 为什么打开一个页面，任务管理器中会有四个进程？

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638691885866-f37dc7b9-f499-4a1c-8eb8-b78c152b87b8.png)



## 进程和线程

### 什么是并行处理

计算机中的并行处理就是同一时刻处理多个任务。

```javascript
A = 1+2;
B = 20/5;
C = 7*8
```

在编写代码的时候，我们可以把这个过程拆分为四个任务：

- 任务 1 是计算 A=1+2；
- 任务 2 是计算 B=20/5；

- 任务 3 是计算 C=7*8；
- 任务 4 是显示最后计算的结果。

单线程来处理的时候，按照任务顺序分别执行这四个任务；

多线程处理的时候，分两步走：第一步，使用三个线程同事执行前三个任务；第二步，再执行第四个显示任务。

所以并行处理能大大提高性能。



### 线程 VS 进程

线程不能单独存在，是由进行来启动和管理的。一个进程就是一个程序的运行实例。

启动一个程序的时候，操作系统会被该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境叫进程。

**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。**



进程和线程关系之间的特点：

- 进程中的任意一线程执行出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据

- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离



## 单进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638695013003-029877e3-bf6f-429a-b3ac-2964305009d6.png)

浏览器所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。如此多的功能模块运行在一个进程里，导致单进程浏览器不稳定、不流畅和不安全。

### 不稳定

web端的视频和游戏需要借助插件来实现各种功能，但是插件容易出现问题，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。

一些复杂的JavaScript代码也可能引起渲染引擎模块的崩溃。

### 不流畅

```javascript
function freeze() { while (1) { console.log("freeze"); }}freeze();
```

浏览器同一时刻只能有一个模块在运行。

当代码中有一段无限循环的代码时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。这样就会导致整个浏览器失去响应，变卡顿。

页面的内存泄露也会导致单进程变慢。

### 不安全

插件和脚本代码可以通过获取系统权限对电脑做出恶意的事情，引发安全问题



## 多进程浏览器

### 早起的多进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638695788856-965323dd-7c10-4d5b-ae37-81dcd80d42e1.png)

Chrome的页面是运行在单独的渲染进程中的，同事页面里的插件也是运行在单独的插件进程之中，而进程之间是通过IPC机制进行通信。

#### 如何解决不稳定？

由于进程之间是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或插件进程，并不会影响到浏览器和其他页面。

#### 如何解决不流畅？

JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面。不会影响到浏览器和其他页面。

#### 如何解决不安全？

采用多进程架构就可以使用安全沙箱，沙箱可以看做是操作系统给进程上的一把锁，沙箱里的程序不会营销到沙箱外的数据、程序、系统等。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。



### 当前的多进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638696677635-448e15c5-0f67-482f-bbc0-b68bf9321bba.png)



> 最新的Chrome浏览器包括：1个浏览器（Browser）进程、1个GPU进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。

- 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页。排版引擎Blink和JavaScript引擎V8都是运行在该进程中，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

>  打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

### 多线程浏览器的问题

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。



> Chrome的默认策略：每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。



# TCP协议：保证页面文件能被完整送达浏览器

## 一个数据包的旅程

### IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合网际协议（IP）标准。计算机地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

- 将客户端主机上的数据包交给网络层
- 网络层再将包含客户端主机和服务端主机地址等信息的IP头附加到数据包上，组成新的IP数据包，并交给后面几个层级。

- 最后通过物理网络将数据包传输到服务端主机。
- 数据包被传输到服务端主机的网络层，在这里服务端拆开数据包的IP头信息，并将拆开来的数据部分交给上层；

- 最终，含有指定信息的数据包就到达了服务端主机的上层。



### UDP：把数据包送达应用程序

IP传输只能将数据包发送到对方电脑，但是却并不知道具体交给哪个程序。这时，便用到了基于IP协议开发的能和应用打交道的协议，较为常见的就是UDP（用户数据包协议）

UDP中一个最重要的信息是端口号，端口号其实就是一个数字，每个访问网络的程序都需要绑定一个端口号。通过端口号UDP秋恩能够把指定的数据包发送给指定的程序了。所以IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。

但是在使用UDP发送数据时，有各种因素会导致数据包出错，并且不提供错误重发机制，只是丢弃当前的包，而且UDP发送后也无法知道是否能到达目的地。

搜索UDP不能保证数据可靠性，但是传输速度非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。



### TCP：把数据完整的送达应用程序

UDP传输往往面临两个问题：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDO协议并不知道如何组装这些数据包，从而把这些数据宝还原成完整的文件。



而使用TCP（传输控制协议）协议有两个特点：

- 对于数据包丢失的情况，TCP提供重传机制；
- TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638802834428-ae455888-4f43-4de5-988a-6db36ed01445.png)



- 首先，建立连接阶段。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- 其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

- 最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

所以TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度。



# HTTP请求流程

## 浏览器发起HTTP请求流程

### 1.构建请求

```javascript
GET /index.html HTTP1.1
```

### 2.查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。

当浏览器发现请求的资源存在缓存时，它会拦截请求，返回该字眼的缓存，并直接结束请求，而不会再去源服务器重新下载。

使用缓存的好处：

- 缓解服务器端压力，提升性能；
- 对于网站来说，缓存是实现快速资源加载的重要组成部分。

如果查找失败，就会进入网络请求过程。

### 3.准备IP地址和端口

浏览器会请求DNS（域名系统）返回域名对应的IP。DNS同样存在缓存，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用。

拿到IP后，获取端口号，通常情况下，URL默认端口号为80端口。



### 4.等待TCP队列

Chrome浏览器机制规定同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下有10个请求发生，那么其中4个请求会进入排队等候状态，直至进行中的请求完成。



### 5.建立TCP连接

TCP三次握手建立连接



### 6.发送HTTP请求

浏览器会向服务器发送请求行，包括了请求方法、请求URI和HTTP版本协议。请求头中包括一些其他信息，比如cookie、host等信息。



## 服务器端处理HTTP请求流程

### 1.返回请求

服务器返回响应行（包括协议版本和状态码）、响应头、响应体。



### 2.断开连接

默认情况下，一旦服务器向客户端返回了请求数据后，就要关闭TCP连接，如果浏览器或者服务器在其头部信息中加入Connection:Keep-Alive，那么TCP就会保持打开状态，保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。



### 3.重定向



## 为什么很多站点第二次打开速度会很块？

如果第二次页面打开的很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。比如DNS缓存和浏览器缓存。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638886887145-f549909a-9883-4472-a393-871929faaa8e.png)



当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的。

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：If-None-Match:"4f80f-13c-3a1xb12a"。服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”如果资源有更新，服务器就直接返回最新资源给浏览器。

简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。



## 登录状态是如何保持的？

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638887017902-b82fb421-5dd9-476d-baf4-a10199e9901a.png)

### 

# 从输入URL到页面展示，这中间发生了什么？

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638973455758-9674a5e1-c53f-4392-9412-85195e5d15bd.png)

- 浏览器进程主要负责用户交互、子进程管理和文件存储等功能。
- 网络进程是面向渲染过程和浏览器进程等提供网络下载功能。

- 渲染进程的主要职责是把从网络下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。



## 从输入URL到页面展示

### 1.用户输入

地址栏会判断用户输入的关键字是搜索内容还是请求的URL。

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
- 如果判断输入内容符合URL规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL。

当用户输入关键字并回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行`beforeunload`事件的机会，`beforeunload`事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未计较完成的表单等情况，因此用户可以通过`beforeunload`事件来取消导航，让浏览器不再执行任何后续工作。

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时页面现实的依然是之前打开的页面内容，并没有立即替换为新页面。因为需要等待提交文档阶段，页面内容才会被替换。



### 2.URL请求过程

浏览器进程通过`进程间通信（IPC）`把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

首先网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。请求前的第一步是要进行DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。

接下来利用IP地址和服务器建立TCP连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接收到请求信息后，会根据请求信息生成相应数据，并发送给网络进程。网络进程会解析响应头的内容。

如果网络进程发现反馈的状态码是301或者302，那么说明浏览器需要重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再次发起请求，重头开始。

如果返回200，那么表示浏览器可以继续处理该请求。

#### 响应数据类型处理

Content-Type是HTTP头中一个非常重要的字段，它告诉浏览器服务器返回的响应体数据时什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。

- text/html ： HTML格式
- text/plain ：纯文本格式

- text/xml ： XML格式
- image/gif ：gif图片格式

- image/jpeg ：jpg图片格式
- image/png：png图片格式

- application/xhtml+xml ：XHTML格式
- application/xml： XML数据格式

- application/atom+xml ：Atom XML聚合格式
- application/json： JSON数据格式

- application/pdf：pdf格式
- application/msword ： Word文档格式

- application/octet-stream ： 二进制流数据（如常见的文件下载）
- application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）



### 3.准备渲染过程

默认情况下，Chrome会每打开一个新页面就配套创建一个新的渲染进程。

如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一个站点的话，那么新页面会复用父页面的渲染进程。（process-per-site-instance）

同一站点定义为根域名加上协议，还包括该根域名下的所有子域名和不同的端口。



### 4.提交文档

浏览器进程将网络进程接收道德HTML数据提交给渲染进程，具体流程为：

- 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息。
- 渲染进程接收到提交文档的消息后，会和网络进程建立传输数据的管道。

- 等文档数据传输完成之后，渲染进程会返回确认提交的消息会浏览器进程。
- 浏览器进程在收到确认提交的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。



### 5.渲染阶段



# 渲染流程

HTML 超文本标记语言 由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容

CSS 又称为层叠样式表，是由选择器和属性组成。
JavaScript，使用它可以使网页的内容“动”起来。

把一个处理HTML、CSS、JS的流程称为渲染流水线。其中包含多个子阶段。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063165196-30c3a478-b8f2-45f8-9ab0-5cd57cacfb32.png)



按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。



## 构建 DOM 树

因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063253728-7618dc32-6f7b-4b42-bc28-460fc32a9d47.png)

构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。

## 样式计算（Recalculate Style）

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

### 1.把 CSS 转换为浏览器能够理解的结构

CSS 样式来源主要有三种：

- 通过 link 引用的外部 CSS 文件
- <style>标记内的 CSS

- 元素的 style 属性内嵌的 CSS

浏览器也无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063405290-bb0da27e-a27d-42e6-b5df-33bc5f9a10ed.png)



### 2.转换样式表中的属性值，使其标准化

```css
body { font-size: 2em }
p {color:blue;}
span  {display: none}
div {font-weight: bold}
div  p {color:green;}
div {color:red; }
```

CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063497291-5c14eba4-119f-4c6d-a276-5eaf942c400d.png)



### 3.计算出 DOM 树中每个节点的具体样式

> CSS 会继承父级节点的样式。

常用可继承属性：

1. 字体系列属性：font-family，font-size

2. 文本系列属性：text-indent，line-height，color

3. 元素可见性：visibility

4. 表格布局属性：border-style

5. 列表布局属性：list-style list-style-type

6. 光标属性：cursor

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063636675-7853d514-6850-4484-b07f-e7f016a8e685.png)



> 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。



## 布局阶段

计算出 DOM 树中可见元素的几何位置的计算过程，叫做布局。

### 1. 创建布局树

DOM中存在不少不可见节点，比如**head标签、script标签、使用display:none的元素**。在显示之前，还要额外地构建一棵只包含可见元素布局树。

为了构建布局树，浏览器大体上完成了下面这些工作：遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；而不可见的节点会被布局树忽略掉。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063929804-5709025c-e42e-4576-afd9-7b0731c34722.png)

### 2. 布局计算



## 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114266076-31cd4627-04d5-45c3-8a94-56aa31b5a70f.png)

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114324617-f7d607de-4486-4383-847f-aba1044eafb4.png)

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。



满足以下两点的元素会被提升为单独的一个图层：

1.拥有层叠上下文属性的元素会被提升为单独的一层。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114402705-028af40b-0411-4c02-8435-b5cba4c26dc9.png)

明确定位属性的元素、定义透明属性的元素、使用css滤镜的元素等，都拥有层叠上下文属性。


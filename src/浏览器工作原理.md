# 为什么打开一个页面，任务管理器中会有四个进程？

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638691885866-f37dc7b9-f499-4a1c-8eb8-b78c152b87b8.png)



## 进程和线程

### 什么是并行处理

计算机中的并行处理就是同一时刻处理多个任务。

```javascript
A = 1+2;
B = 20/5;
C = 7*8
```

在编写代码的时候，我们可以把这个过程拆分为四个任务：

- 任务 1 是计算 A=1+2；
- 任务 2 是计算 B=20/5；

- 任务 3 是计算 C=7*8；
- 任务 4 是显示最后计算的结果。

单线程来处理的时候，按照任务顺序分别执行这四个任务；

多线程处理的时候，分两步走：第一步，使用三个线程同事执行前三个任务；第二步，再执行第四个显示任务。

所以并行处理能大大提高性能。



### 线程 VS 进程

线程不能单独存在，是由进行来启动和管理的。一个进程就是一个程序的运行实例。

启动一个程序的时候，操作系统会被该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境叫进程。

**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。**



进程和线程关系之间的特点：

- 进程中的任意一线程执行出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据

- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离



## 单进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638695013003-029877e3-bf6f-429a-b3ac-2964305009d6.png)

浏览器所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。如此多的功能模块运行在一个进程里，导致单进程浏览器不稳定、不流畅和不安全。

### 不稳定

web端的视频和游戏需要借助插件来实现各种功能，但是插件容易出现问题，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。

一些复杂的JavaScript代码也可能引起渲染引擎模块的崩溃。

### 不流畅

```javascript
function freeze() { while (1) { console.log("freeze"); }}freeze();
```

浏览器同一时刻只能有一个模块在运行。

当代码中有一段无限循环的代码时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。这样就会导致整个浏览器失去响应，变卡顿。

页面的内存泄露也会导致单进程变慢。

### 不安全

插件和脚本代码可以通过获取系统权限对电脑做出恶意的事情，引发安全问题



## 多进程浏览器

### 早起的多进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638695788856-965323dd-7c10-4d5b-ae37-81dcd80d42e1.png)

Chrome的页面是运行在单独的渲染进程中的，同事页面里的插件也是运行在单独的插件进程之中，而进程之间是通过IPC机制进行通信。

#### 如何解决不稳定？

由于进程之间是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或插件进程，并不会影响到浏览器和其他页面。

#### 如何解决不流畅？

JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面。不会影响到浏览器和其他页面。

#### 如何解决不安全？

采用多进程架构就可以使用安全沙箱，沙箱可以看做是操作系统给进程上的一把锁，沙箱里的程序不会营销到沙箱外的数据、程序、系统等。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。



### 当前的多进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638696677635-448e15c5-0f67-482f-bbc0-b68bf9321bba.png)



> 最新的Chrome浏览器包括：1个浏览器（Browser）进程、1个GPU进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。

- 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页。排版引擎Blink和JavaScript引擎V8都是运行在该进程中，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

>  打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

### 多线程浏览器的问题

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。



> Chrome的默认策略：每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。



# TCP协议：保证页面文件能被完整送达浏览器

## 一个数据包的旅程

### IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合网际协议（IP）标准。计算机地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

- 将客户端主机上的数据包交给网络层
- 网络层再将包含客户端主机和服务端主机地址等信息的IP头附加到数据包上，组成新的IP数据包，并交给后面几个层级。

- 最后通过物理网络将数据包传输到服务端主机。
- 数据包被传输到服务端主机的网络层，在这里服务端拆开数据包的IP头信息，并将拆开来的数据部分交给上层；

- 最终，含有指定信息的数据包就到达了服务端主机的上层。



### UDP：把数据包送达应用程序

IP传输只能将数据包发送到对方电脑，但是却并不知道具体交给哪个程序。这时，便用到了基于IP协议开发的能和应用打交道的协议，较为常见的就是UDP（用户数据包协议）

UDP中一个最重要的信息是端口号，端口号其实就是一个数字，每个访问网络的程序都需要绑定一个端口号。通过端口号UDP秋恩能够把指定的数据包发送给指定的程序了。所以IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。

但是在使用UDP发送数据时，有各种因素会导致数据包出错，并且不提供错误重发机制，只是丢弃当前的包，而且UDP发送后也无法知道是否能到达目的地。

搜索UDP不能保证数据可靠性，但是传输速度非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。



### TCP：把数据完整的送达应用程序

UDP传输往往面临两个问题：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDO协议并不知道如何组装这些数据包，从而把这些数据宝还原成完整的文件。



而使用TCP（传输控制协议）协议有两个特点：

- 对于数据包丢失的情况，TCP提供重传机制；
- TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638802834428-ae455888-4f43-4de5-988a-6db36ed01445.png)



- 首先，建立连接阶段。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- 其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

- 最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

所以TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度。



# HTTP请求流程

## 浏览器发起HTTP请求流程

### 1.构建请求

```javascript
GET /index.html HTTP1.1
```

### 2.查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。

当浏览器发现请求的资源存在缓存时，它会拦截请求，返回该字眼的缓存，并直接结束请求，而不会再去源服务器重新下载。

使用缓存的好处：

- 缓解服务器端压力，提升性能；
- 对于网站来说，缓存是实现快速资源加载的重要组成部分。

如果查找失败，就会进入网络请求过程。

### 3.准备IP地址和端口

浏览器会请求DNS（域名系统）返回域名对应的IP。DNS同样存在缓存，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用。

拿到IP后，获取端口号，通常情况下，URL默认端口号为80端口。



### 4.等待TCP队列

Chrome浏览器机制规定同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下有10个请求发生，那么其中4个请求会进入排队等候状态，直至进行中的请求完成。



### 5.建立TCP连接

TCP三次握手建立连接



### 6.发送HTTP请求

浏览器会向服务器发送请求行，包括了请求方法、请求URI和HTTP版本协议。请求头中包括一些其他信息，比如cookie、host等信息。



## 服务器端处理HTTP请求流程

### 1.返回请求

服务器返回响应行（包括协议版本和状态码）、响应头、响应体。



### 2.断开连接

默认情况下，一旦服务器向客户端返回了请求数据后，就要关闭TCP连接，如果浏览器或者服务器在其头部信息中加入Connection:Keep-Alive，那么TCP就会保持打开状态，保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。



### 3.重定向



## 为什么很多站点第二次打开速度会很块？

如果第二次页面打开的很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。比如DNS缓存和浏览器缓存。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638886887145-f549909a-9883-4472-a393-871929faaa8e.png)



当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的。

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：If-None-Match:"4f80f-13c-3a1xb12a"。服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”如果资源有更新，服务器就直接返回最新资源给浏览器。

简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。



## 登录状态是如何保持的？

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638887017902-b82fb421-5dd9-476d-baf4-a10199e9901a.png)

### 

# 从输入URL到页面展示，这中间发生了什么？

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638973455758-9674a5e1-c53f-4392-9412-85195e5d15bd.png)

- 浏览器进程主要负责用户交互、子进程管理和文件存储等功能。
- 网络进程是面向渲染过程和浏览器进程等提供网络下载功能。

- 渲染进程的主要职责是把从网络下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。



## 从输入URL到页面展示

### 1.用户输入

地址栏会判断用户输入的关键字是搜索内容还是请求的URL。

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
- 如果判断输入内容符合URL规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL。

当用户输入关键字并回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行`beforeunload`事件的机会，`beforeunload`事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未计较完成的表单等情况，因此用户可以通过`beforeunload`事件来取消导航，让浏览器不再执行任何后续工作。

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时页面现实的依然是之前打开的页面内容，并没有立即替换为新页面。因为需要等待提交文档阶段，页面内容才会被替换。



### 2.URL请求过程

浏览器进程通过`进程间通信（IPC）`把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

首先网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。请求前的第一步是要进行DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。

接下来利用IP地址和服务器建立TCP连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接收到请求信息后，会根据请求信息生成相应数据，并发送给网络进程。网络进程会解析响应头的内容。

如果网络进程发现反馈的状态码是301或者302，那么说明浏览器需要重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再次发起请求，重头开始。

如果返回200，那么表示浏览器可以继续处理该请求。

#### 响应数据类型处理

Content-Type是HTTP头中一个非常重要的字段，它告诉浏览器服务器返回的响应体数据时什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。

- text/html ： HTML格式
- text/plain ：纯文本格式

- text/xml ： XML格式
- image/gif ：gif图片格式

- image/jpeg ：jpg图片格式
- image/png：png图片格式

- application/xhtml+xml ：XHTML格式
- application/xml： XML数据格式

- application/atom+xml ：Atom XML聚合格式
- application/json： JSON数据格式

- application/pdf：pdf格式
- application/msword ： Word文档格式

- application/octet-stream ： 二进制流数据（如常见的文件下载）
- application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）



### 3.准备渲染过程

默认情况下，Chrome会每打开一个新页面就配套创建一个新的渲染进程。

如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一个站点的话，那么新页面会复用父页面的渲染进程。（process-per-site-instance）

同一站点定义为根域名加上协议，还包括该根域名下的所有子域名和不同的端口。



### 4.提交文档

浏览器进程将网络进程接收道德HTML数据提交给渲染进程，具体流程为：

- 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息。
- 渲染进程接收到提交文档的消息后，会和网络进程建立传输数据的管道。

- 等文档数据传输完成之后，渲染进程会返回确认提交的消息会浏览器进程。
- 浏览器进程在收到确认提交的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。



### 5.渲染阶段



# 渲染流程

HTML 超文本标记语言 由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容

CSS 又称为层叠样式表，是由选择器和属性组成。
JavaScript，使用它可以使网页的内容“动”起来。

把一个处理HTML、CSS、JS的流程称为渲染流水线。其中包含多个子阶段。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063165196-30c3a478-b8f2-45f8-9ab0-5cd57cacfb32.png)



按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。



## 构建 DOM 树

因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063253728-7618dc32-6f7b-4b42-bc28-460fc32a9d47.png)

构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。

## 样式计算（Recalculate Style）

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

### 1.把 CSS 转换为浏览器能够理解的结构

CSS 样式来源主要有三种：

- 通过 link 引用的外部 CSS 文件
- <style>标记内的 CSS

- 元素的 style 属性内嵌的 CSS

浏览器也无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063405290-bb0da27e-a27d-42e6-b5df-33bc5f9a10ed.png)



### 2.转换样式表中的属性值，使其标准化

```css
body { font-size: 2em }
p {color:blue;}
span  {display: none}
div {font-weight: bold}
div  p {color:green;}
div {color:red; }
```

CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063497291-5c14eba4-119f-4c6d-a276-5eaf942c400d.png)



### 3.计算出 DOM 树中每个节点的具体样式

> CSS 会继承父级节点的样式。

常用可继承属性：

1. 字体系列属性：font-family，font-size

2. 文本系列属性：text-indent，line-height，color

3. 元素可见性：visibility

4. 表格布局属性：border-style

5. 列表布局属性：list-style list-style-type

6. 光标属性：cursor

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063636675-7853d514-6850-4484-b07f-e7f016a8e685.png)



> 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。



## 布局阶段

计算出 DOM 树中可见元素的几何位置的计算过程，叫做布局。

### 1. 创建布局树

DOM中存在不少不可见节点，比如**head标签、script标签、使用display:none的元素**。在显示之前，还要额外地构建一棵只包含可见元素布局树。

为了构建布局树，浏览器大体上完成了下面这些工作：遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；而不可见的节点会被布局树忽略掉。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063929804-5709025c-e42e-4576-afd9-7b0731c34722.png)

### 2. 布局计算



## 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114266076-31cd4627-04d5-45c3-8a94-56aa31b5a70f.png)

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114324617-f7d607de-4486-4383-847f-aba1044eafb4.png)

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

满足以下两点的元素会被提升为单独的一个图层：

### 1.拥有层叠上下文属性的元素会被提升为单独的一层。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114402705-028af40b-0411-4c02-8435-b5cba4c26dc9.png)

明确定位属性的元素、定义透明属性的元素、使用css滤镜的元素等，都拥有层叠上下文属性。



### 2.需要剪裁（clip）的地方也会被创建为图层。

固定大小的元素内，内容过长会出现裁剪。渲染引擎会把裁剪文字内容的一部分用于显示在元素区域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639220143431-15a02a20-1bf3-4d15-a88c-ba55905ceda6.png)





## 图层绘制

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

在图层绘制阶段，输出的就是这些待绘制列表。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639220355573-5fcb0723-396a-4307-8ea6-5c3d824feadb.png)



## 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。

浏览器不会一次绘制出所有图层的内容，只会绘制当前可视窗口的内容。基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639221484771-841ba4e1-933b-45f9-a5e6-629a5532e17a.png)



## 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。





![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639221740082-c280578b-c5ec-4e44-822e-00a610ba84d9.png)

**一个完整的渲染流程大致可为：**

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

1. 创建布局树，并计算元素的布局信息。
2. 对布局树进行分层，并生成分层树。

1. 为每个图层生成绘制列表，并将其提交到合成线程。
2. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。

1. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
2. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。



## 更新了元素的几何属性（重排）

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639222463479-00d70cf7-7229-4269-bec5-7a51c76efbd4.png)



如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排需要更新完整的渲染流水线，所以开销也是最大的。



## 更新元素的绘制属性（重绘）

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639222513286-a9f2ed9f-fb45-4247-b307-8d9b9529f807.png)

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。



## 直接合成阶段

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639222548440-06229c90-5c04-4c75-9160-f2a18de48c64.png)

使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。



## 减少重排重绘的方法



- 使用 class 操作样式，而不是频繁操作 style
- 避免使用 table 布局

- 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
- Debounce window resize 事件

- 对 dom 属性的读写要分离
- will-change: transform 做优化
- 等等



# 变量提升

- 在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。
- 在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。

- 在一个函数定义之前使用它，不会出错，且函数能正确执行。

>  所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值 undefined。

## JavaScript 代码的执行流程

变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639317427890-e8534e38-0e04-4d9f-8849-8ff6ad78d8bd.png)

### 1.编译阶段

```javascript
showName();
console.log(name);
var name = 'wangyu';
function showName() {
	console.log('函数执行');
}

// 变量提升
var name = undefined;
function showName() {
	console.log('函数执行');
}

// 执行部分
showName();
console.log(name);
name = 'wangyu';
```

输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

在执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容，比如name、showName，都保存在该对象中。



### 2.执行阶段

- 当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出结果。
- 接下来打印“name”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 name 变量，并且其值为 undefined，所以这时候就输出 undefined。

- 接下来，把“wangyu”赋给 name 变量，赋值后变量环境中的 name 属性值改变为“wangyu”



## 代码中出现相同的变量或者函数怎么办？

```javascript
function showName() {
    console.log('wangyu');
}
showName(); // jiangyu
function showName() {
    console.log('jiangyu');
}
showName(); // jiangyu
```

- 首先是编译阶段。遇到了第一个 showName 函数，会将该函数体存放到变量环境中。接下来是第二个 showName 函数，继续存放至变量环境中，但是变量环境中已经存在一个 showName 函数了，此时，第二个 showName 函数会将第一个 showName 函数覆盖掉。这样变量环境中就只存在第二个 showName 函数了。
- 接下来是执行阶段。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数，打印的内容是“jiangyu”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“jiangyu”。



所以一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。





# 为什么JavaScript会出现栈溢出？

## 什么是栈？

一条单车道的单行线，一端被堵住了，而另一端入口处没有任何提示信息，堵住之后就只能后进去的车子先出来，这时这个堵住的单行线就可以被看作是一个栈容器，车子开进单行线的操作叫做入栈，车子倒出去的操作叫做出栈。

在车流量较大的场景中，就会发生反复的入栈、栈满、出栈、空栈和再次入栈，一直循环。

所以，栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足后进先出的特点。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396242941-0fb3d773-06e8-45c9-9a09-ef91e5f073e0.png)



## 什么是JavaScript调用栈

JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称**调用栈**。

```javascript
var a = 2
function add(b,c){
  return b+c
}
function addAll(b,c){
var d = 10
result = add(b,c)
return  a+result+d
}
addAll(3,6)
```

执行这段代码时：

**第一步，创建全局上下文，并将其压入栈底**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396346889-d6b5390e-fa3b-4437-9139-077295e71bc7.png)

全局执行上下文入栈以后，JavaScript引擎就开始执行全局代码了。首先执行a = 2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。



**第二步是调用addAll函数**

当调用该函数时，JavaScript引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396470177-cf0c739d-6d29-4561-95ed-30d84a985975.png)



**第三步，执行add函数**

同样 JavaScript引擎会为其创建执行上下文，并将其压入调用栈。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396515810-86fc038a-7a1f-43d2-a463-ee85daa77bd2.png)

当add函数执行完后，add的执行上下文出栈，当addAll函数执行完成后，addAll的执行上下文也会从栈顶弹出，只留下全局执行上下文。



利用浏览器来查看调用栈的信息。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396621571-6c67d1a1-6e78-41cb-8c1b-d203e051ccc1.png)



## 栈溢出

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，这种错误就是栈溢出。

```javascript
function division(a,b){
    return division(a,b)
}
console.log(division(1,2)) // Maximum call stack size exceeded
```

当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。



# 块级作用域

## 作用域（scope）

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。

- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。



块级作用域则是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句等都可以看做是块级作用域。

```javascript
if (true) {}

function foo() {}

while(true) {}

{}

for () {}

try {} catch {}
```

## 变量提升所带来的问题

1. 变量容易在不被察觉的情况下被覆盖掉

```javascript
var myname = "wangyu"
function showName(){
  console.log(myname); // undefined
  if(0){
   var myname = "jiangyu"
  }
  console.log(myname); // undefined
}
showName()

// showName函数内容有var声明的变量，导致会在编译时存在变量提升。
```

1. 本应销毁的变量没有被销毁

```javascript
function foo(){
  for (var i = 0; i < 7; i++) {
  }
  console.log(i); // 7  因为变量i在foo函数作用域内变量提升，所以i++的赋值一直都是同一个i变量
}
foo()
```

## let 和 const

```javascript
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

**第一步 编译并创建执行上下文**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639494287485-52ecfdf8-dc07-4c6a-a37a-0dc33b4668cd.png)

let声明的变量会被存放到词法环境中，而var声明的变量被存放到变量环境中，不过此时在函数作用域内的块级作用域内，通过let声明的变量并没有被存放到词法环境中。



**第二步 继续执行代码**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639494427514-5b25e663-a43b-4a5a-b20c-ba2ddb8a58fd.png)

当代码执行到函数内块级作用域里面的时候，let声明的变量会被存放到词法环境的一个单独的区域中，这个区域中的变量不会影响到块级作用域外面的变量。比如函数内部的两个b变量，是独立存在的、互不影响的。

词法环境也是一个栈结构，占地是函数最外层的变量，进入一个块级作用域，就会把该作用域内部的变量压到栈顶。当作用域执行完成之后，该作用域的信息就会从栈顶弹出。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639494627544-bd37da44-dbf4-4d83-b0e9-33ca4308adbd.png)



# 作用域链和闭包

```javascript
function bar() {
    console.log(myName) // wangyu
}
function foo() {
    var myName = "jiangyu"
    bar()
}
var myName = "wangyu"
foo()

// 为什么打印的是“wangyu”?
```

## 作用域链

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，把这个外部引用称为 outer。

当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量。

bar函数和foo函数的outer都是指向全局上下文的，这也就意味着如何在bar函数或者foo函数中使用了外部变量，那么JavaScript引擎会去全局执行上下文中查找。这种查找的链条就是作用域链。



## 词法作用域

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639579048709-c5cc1262-5d04-4ad6-9cf1-f7baf781363a.png)

从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。



根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。

```javascript
function bar() {
    var myName = "yu1"
    let test1 = 100
    if (1) {
        let myName = "yu2"
        console.log(test); // 1
      	console.log(myName); // yu2
    }
}
function foo() {
    var myName = "yu3"
    let test = 2
    {
        let test = 3
        bar()
    }
}
var myName = "yu4"
let myAge = 10
let test = 1
foo()
```



## 闭包

```javascript
function foo() {
    var myName = "wangyu"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("jiangyu")
bar.getName()
console.log(bar.getName())
```

根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量。所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。

foo函数执行完之后，其执行上下文从栈顶弹出，但是由于myName和test1变量还被bar所引用，所以这两个变量依然保存在内存中。



在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639580682200-83b7fe70-85c2-4a21-a5b7-d2d11ed23448.png)



## 闭包是怎样回收的？

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。



# this

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640083534364-2d9c0517-5af6-48fc-84dc-2da56dfa1969.png)

在JavaScript中，this是和执行上下文绑定的，每个执行上下文都有一个this。



全局执行上下文中的this指向的是window对象。

全局上下文中调用的函数中的this，默认也是window对象。

## 设置函数执行上下文中的this值。

### 1.通过函数的call方式设置。

```javascript
var bar = {
  myName : "wangyu",
  test1 : 1
}
function foo(){
  this.myName = "jiangyu"
}
foo.call(bar)
console.log(bar) // {myName: jiangyu, ...}
console.log(myName) // 未定义
```

### 2.通过对象调用方法设置

```javascript
var myObj = {
  name : "wangyu", 
  showThis: function(){
    console.log(this)
  }
}
myObj.showThis() // wangyu
```

### 3.通过构造函数中设置

```javascript
function CreateObj(){
  this.name = "wangyu"
}
var myObj = new CreateObj()
```

当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：

- 首先创建了一个空对象 tempObj；
- 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；

- 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；
- 最后返回 tempObj 对象。



## this的设计缺陷及应对方案

### 1.嵌套函数中的this不会从外层函数中继承

```javascript
var myObj = {
  name : "wangyu", 
  showThis: function(){
    console.log(this) // mObj
    function bar(){console.log(this)} // window
    bar()
  }
}
myObj.showThis()

// showThis函数中可以用一个变量保存this。然后在bar函数中使用
showThis: function(){
  console.log(this)
  var self = this
  function bar(){
    self.name = "11"
  }
  bar()
}

// 使用箭头函数，箭头函数不会创建其自身的执行上下文。
// 所以箭头函数中的this取决于它的外部函数。
showThis: function(){
  console.log(this)
  var bar = ()=>{
    this.name = "22"
    console.log(this)
  }
  bar()
}
```

### 2.普通函数中的this默认指向全局对象window

可添加严格模式，其函数的执行上下文中的this值是undefined。



# 消息队列和事件循环

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640185215076-6307ceff-b365-423a-8370-10a1022f738e.png)

渲染进程专门有一个IO线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务放入消息对象发送给主线程。主线程在空闲时会通过事件循环依次取出消息队列中的任务执行。

消息队列中的任务类型包括输入事件、微任务、文件读写、WebSocket、JavaScript定时器等，还包括JavaScript执行、解析DOM、样式计算、布局计算、CSS动画等。



当页面主线程执行完成之后，Chrome确认要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志，如果设置了，那么就直接中断当前的所有任务，退出线程。

## 页面使用单线程的缺点

**第一个问题是如果处理高优先级的任务**

如果此时需要存在一个能力，监听DOM节点的变化情况，那么此时，如果每次DOM变化同步调用对应接口，那么在DOM变更过于频繁的时候，会阻塞其他事件进行，而如果采用异步的方式，监听时的时间不精准。

这种情况下，出现了微任务，微任务会在当前宏任务执行完后执行。这样，监听的实时性就大大提高。



**第二个问题是单个任务执行时长过久**

这种情况下应该通过回调功能来规避此类问题



# setTimeout

[MDN-setTimeout](https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout)

setTimeout是一个定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。setTimeout的执行最小间隔为4毫秒。

```javascript
function showName(){
  console.log("start")
}
var timerID = setTimeout(showName,200);
clearTimeout(timerID);
```

在Chrome中除了正常使用的消息队列之外，还有另外一个消息队列（hashmap结构），这个队列中维护了需要延时执行的任务列表，包括了定时器和Chromium内部以下需要延迟执行的任务。所以当通过JavaScript创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数、当前发起时间、延迟执行时间。创建好回调任务之后，再将该任务添加到延迟执行队列中。

消息队列中的任务执行完之后，就是去执行延迟队列中到期的任务。

## 使用setTimeout的一些注意事项

- 如果当前任务执行时间过久，会影响定时器任务的执行。
- 如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4毫秒。

- - 因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。

```javascript
function cb() { setTimeout(cb, 0); }
setTimeout(cb, 0);
```

- 未激活的页面，setTimeout执行最小间隔是1000毫秒。
- 延迟执行时间有最大值。

- - Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。

- 使用setTimeout时回调函数中的this指向问题

- - 如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。

```javascript
var name= 1;
var MyObj = {
  name: 2,
  showName: function(){
    console.log(this.name); // 1
  }
}
setTimeout(MyObj.showName,1000);

// 解决办法

//箭头函数
setTimeout(() => {
    MyObj.showName()
}, 1000);
//或者function函数
setTimeout(function() {
  MyObj.showName();
}, 1000)

// bind
setTimeout(MyObj.showName.bind(MyObj), 1000)
```



# XMLHttpRequest

XMLHttpRequest提供了从web服务器获取数据的能力。

## 系统调用栈

当循环系统在执行一个任务的时候，都会为这个任务维护一个系统调用栈。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640351083047-f9ee1959-3fd5-4623-acae-9968b22c645a.png)

黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。通过该图可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。

整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。



## XMLHttpRequest运行机制

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640351264910-b2b653cf-ed24-44c0-a64f-27262a7564b6.png)

```javascript
 function GetWebData(URL){
    /**
     * 1:新建XMLHttpRequest请求对象
     */
    let xhr = new XMLHttpRequest()

    /**
     * 2:注册相关事件回调处理函数 
     */
    xhr.onreadystatechange = function () {
        switch(xhr.readyState){
          case 0: //请求未初始化
            console.log("请求未初始化")
            break;
          case 1://OPENED
            console.log("OPENED")
            break;
          case 2://HEADERS_RECEIVED
            console.log("HEADERS_RECEIVED")
            break;
          case 3://LOADING  
            console.log("LOADING")
            break;
          case 4://DONE
            if(this.status == 200||this.status == 304){
                console.log(this.responseText);
                }
            console.log("DONE")
            break;
        }
    }

    xhr.ontimeout = function(e) { console.log('ontimeout') }
    xhr.onerror = function(e) { console.log('onerror') }

    /**
     * 3:打开请求
     */
    xhr.open('Get', URL, true);//创建一个Get请求,采用异步


    /**
     * 4:配置参数
     */
    xhr.timeout = 3000 //设置xhr请求的超时时间
    xhr.responseType = "text" //设置响应返回的数据格式
    xhr.setRequestHeader("X_TEST","time.geekbang")

    /**
     * 5:发送请求
     */
    xhr.send();
}
```

- 第一步：创建XMLHttpRequest对象
- 第二步：为xhr对象注册回调函数

- - 因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。
  - XMLHttpRequest 的回调函数主要有下面几种：

- - - ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；
    - onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；

- - - onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。

- 第三步：配置基础的请求信息

- - 通过open接口配置一些基础的请求信息，包括请求的地址、请求方法和请求方式。然后通过xhr内部属性类配一些其他可选的请求信息。

- 第四步：发起请求

- - 通过xhr.send发起网络请求。
  - 如果网络请求出错了，就会执行 xhr.onerror；

- - 如果超时了，就会执行 xhr.ontimeout；
  - 如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。



## XMLHttpRequest使用过程中的问题

- 跨域问题
- https混合内容的问题

- - 在https的网站中请求http的接口，会报错



# 宏任务和微任务

## 宏任务

为了协调任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为宏任务。



WHATWG 规范定义事件循环机制的大致流程：

- 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
- 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；

- 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
- 最后统计执行完成的时长等信息。



宏任务的时间精度不够，容易被中间的任务执行所影响。



## 微任务

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。

微任务包括MutationObserver和Promise。

通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。

如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640437284920-5f69b43d-8e72-4f84-942f-a9569218a0de.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640437294249-33b7d119-6354-4706-ab11-3174df39d528.png)



## MutationObserver

```javascript
const targetNode = document.getElementById('box');
const config = { attributes: true, childList: true, subtree: true };
const callback = (mutationsList) => {
  console.log('dom更新', mutationsList);
};
const observer = new MutationObserver(callback);

observer.observe(targetNode, config);
setTimeout(() => {
  targetNode.innerHTML = 222;
}, 3000);
```



# async/await

## 生成器 VS 协程

生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的

```javascript
function* genDemo() {
    console.log("开始执行第一段")
    yield 'generator 2'

    console.log("开始执行第二段")
    yield 'generator 2'

    console.log("开始执行第三段")
    yield 'generator 2'

    console.log("执行结束")
    return 'generator 2'
}

console.log('main 0')
let gen = genDemo()
console.log(gen.next().value)
console.log('main 1')
console.log(gen.next().value)
console.log('main 2')
console.log(gen.next().value)
console.log('main 3')
console.log(gen.next().value)
console.log('main 4')
```

- 在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。
- 外部函数可以通过 next 方法恢复函数的执行。



协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。

协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

线程是由CPU进行调度的，CPU的一个时间片内只执行一个线程上下文内的线程，当CPU由执行线程A切换到执行线程B的过程中会发生一系列的操作，这些操作主要有”保存线程A的执行现场“然后”载入线程B的执行现场”，这个过程称之为“上下文切换（context switch）”,这个上下文切换过程并不廉价，如果没有必要，应该尽量减少上下文切换的发生。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640527960354-24c2080a-aa64-4c29-bf27-dba5d8a4678c.png)



- 通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。
- 要让 gen 协程执行，需要通过调用 gen.next。

- 当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。
- 如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。



调用栈如何切换？

- 第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。
- 第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640528587898-e8215028-a986-419e-834e-94e71e1aeba1.png)





## async

async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。

```javascript
async function foo() {
    return 2
}
console.log(foo())  // Promise {<resolved>: 2}
```

## await

```javascript
async function foo() {
    console.log(1)
    let a = await 100
    console.log(a)
    console.log(2)
}
console.log(0)
foo()
console.log(3)
// 0 1 3 100 2
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640528998603-a4836e6b-7e03-4795-ba42-617c6df81510.png)



# DOM树

## 什么是DOM

从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用。

- 从页面的视角来看，DOM 是生成页面的基础数据结构。
- 从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。

- 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。



## DOM树如何生成

在渲染引擎内部，有一个叫HTML解析器的模块，它的职责就是负责将HTML字节流转换为DOM结构。

HTML解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML解析器便解析多少数据。



网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640614930344-047959f6-c645-4de4-b0d2-609a49b812cb.png)

**第一个阶段，通过分词器将字节流转换为Token。**

解析HTML分为Tag Token 和 文本Token。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640615000002-1c7c5188-22d0-412d-8d7b-4bdfd1c108d9.png)

Tag Token 又分 `StartTag` 和 `EndTag`，分别对于图中的蓝色和红色块，文本 Token 对应的绿色块。



**第二个和第三个阶段是同步进行的，需要将Token解析为DOM节点，并将DOM节点添加到DOM树中。**

HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：

- 如果压入到栈中的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
- 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。

- 如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。

通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。



## JavaScript如何影响DOM生成的



因为js脚本可能要修改当前已经生成的DOM结构，所以渲染引擎解析到script标签的时候，会暂停DOM的解析。

Chrome 浏览器对此做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。

async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。



当在JavaScript脚本中需要操作CSSOM时，在解析JavaScript脚本之前还要解析脚本之上所有的CSS样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。

而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。所以说 JavaScript 脚本是依赖样式表的。



# CSS如何影响首次加载时的白屏时间



含有CSS的页面渲染流水线

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640701580544-d6fd7aa8-3d07-485f-b452-941fb7c1677c.png)

首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。

当有CSS的时候，预解析线程会解析出来一个外部的 css 文件，并发起 css文件 的下载。在 DOM 构建结束之后、css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。



## 渲染流水线为什么需要CSSOM？

和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个 CSSOM 体现在 DOM 中就是document.styleSheets。



含有JavaScript和CSS页面渲染流水线

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640702024364-09659e15-0d8f-406d-8e78-020c5622594c.png)

在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。



## 影响页面展示的因素以及优化策略

从数据提交之后到准备渲染前，渲染进程会创建一个空白页面，等待文件加载完成，生成CSSOM和DOM，这段时间通常被称为解析白屏。如果白屏时间过久，就会影响到用户体验。

通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。

所以要想缩短白屏时长，可以有以下策略：

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。

- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。



# 分层与合成机制



## 显示器是怎么显示图像的？

每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。

显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。



## 帧 VS 帧率

当滚动、缩放页面时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。

浏览器卡顿就是因为丢帧。



## 如何生成一帧图像

生成一帧的方式有重排、重绘和合成三种方式。这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。

合成操作的路径相对来说非常短，并不需要触发布局和绘制两个阶段，如果采用了CPU，那么合成的效率会非常高。



## 分层和合成

每个网页都是由多个图层叠加到一起的，Chrome合成器最终把这些图层合成了用于显示页面的图片。

在Chrome的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。

层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。

有了绘制列表之后，就需要进入光栅化阶段，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。



## 分块

分层是从宏观上提升了渲染效率，分块则是从微观层面提升了渲染效率。

通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。

因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。

为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。



## 如何利用分层技术优化代码

```css
.box {
will-change: transform, opacity;
}
```

使用 **will-change** 来告诉渲染引擎你会对该元素做一些特效变换。

这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。

但是当图层过多时，占用的内存也会大大增加。所以需要恰当的使用will-change。



# 如何优化页面？

通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。

- 加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
- 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。

- 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。



## 加载阶段

加载资源时并不是所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件，而JavaScript、首次请求的HTML、CSS是会阻塞首次渲染的。

把能阻塞网页首次渲染的资源称为关键资源。基于关键资源，细化出三个影响页面首次渲染的核心因素。

第一个是关键资源个数。个数越多，首次页面的加载时间就会越长。

第二个是关键资源大小。关键资源越小，其整个资源的下载时间也就越短。

第三个是请求关键资源需要多少个RTT（Round Trip Time）。RTT表示的是往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到接收端的确认，总共经历的时延。。通常1个HTTP的数据包在14KB左右。



加载阶段的主要优化原则是减少关键资源个数，降低关键资源大小，降低关键资源的RTT次数。

- 减少关键资源个数，第一种方法是将JavaScript和CSS改成内联的形式。另一种方法是如果JavaScript代码没有DOM或者CSSOM的操作、CSS不是在构建页面前必须加载的，可以通过添加属性变为非关键资源。
- 减少资源大小，可以通过压缩CSS和JavaScript资源、移除注释内容等方式。

- 减少关键资源RTT的次数，可以通过减少关键资源的个数和大小搭配来实现。



## 交互阶段

在交互阶段，帧的渲染速度决定了交互的流畅度。因此交互阶段的页面优化就是在优化渲染引擎渲染帧的速度。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640874068173-a404d62f-cc4a-458e-9c16-3cc2f2d2ac1d.png)



大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。

如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。

同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。

还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。



### 减少JavaScript脚本执行时间

- 将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。
- 采用Web Workers。不过Web Workers中没有DOM和CSSOM环境。所以需要把一些与DOM操作无关且耗时的任务放到Web Workers中去执行。

### 避免强制同步布局

```html
<html>
<body>
    <div id="mian_div">
        <li id="time_li">wangyu</li>
        <li>geekbang</li>
    </div>

    <p id="demo">强制布局demo</p>
    <button onclick="foo()">添加新元素</button>

    <script>
        function foo() {
            let main_div = document.getElementById("mian_div")      
            let new_node = document.createElement("li")
            let textnode = document.createTextNode("jiangyu")
            new_node.appendChild(textnode);
            document.getElementById("mian_div").appendChild(new_node);
        }
    </script>
</body>
</html>
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640874309343-1bfd6441-edf8-43ce-861c-8f41c1999849.png)

执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这是正常情况下的布局操作。

而强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。

```javascript
function foo() {
    let main_div = document.getElementById("mian_div")
    let new_node = document.createElement("li")
    let textnode = document.createTextNode("jiangyu")
    new_node.appendChild(textnode);
    document.getElementById("mian_div").appendChild(new_node);
    //由于要获取到offsetHeight，
    //但是此时的offsetHeight还是老的数据，
    //所以需要立即执行布局操作
    console.log(main_div.offsetHeight)
}
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640874434034-c9070918-42b1-4d5c-8d89-f5a11d7724a2.png)

将元素添加到DOM之后，又立即获取节点的高度信息。如果要获取到 节点的高度，就需要重新布局，所以这里在获取到节点的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。



### 避免布局抖动

所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。

```javascript
function foo() {
    let time_li = document.getElementById("time_li")
    for (let i = 0; i < 100; i++) {
        let main_div = document.getElementById("mian_div")
        let new_node = document.createElement("li")
        let textnode = document.createTextNode("time.geekbang")
        new_node.appendChild(textnode);
        new_node.offsetHeight = time_li.offsetHeight;
        document.getElementById("mian_div").appendChild(new_node);
    }
}
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640874552374-ac50de3f-332f-4d77-b5ac-478c0bbe18cb.png)



### 合理利用CSS合成动画

合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。



### 避免频繁的垃圾回收

如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。

所以要尽量避免产生那些临时垃圾数据。可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。



# 虚拟DOM

## DOM的缺陷

操作DOM后，就会触发样式计算、布局、绘制、栅格化、合成等一些列任务，可能导致重排、重绘或者合成操作。对DOM的不当操作还有可能引发强制同步布局和布局抖动问题，这些操作都会大大降低渲染效率。



## 什么是虚拟DOM

虚拟DOM应该要解决的事情

- 将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。
- 变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。

- 在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640960238801-81e5e261-5512-4683-a9b4-ba5a0d715681.png)

- **创建阶段**。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。
- **更新阶段**。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。



### 双缓存

在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。

而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。

把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。



### MVC模式

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640960498936-a2d60e5a-9d4b-440b-afc2-cba2afdbf9de.png)

MVC 的整体结构比较简单，由模型、视图和控制器组成，其核心思想就是将数据和视图分离，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640960528551-d5758bb9-a436-48f1-b388-a036eb602f17.png)

把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：

- 图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；
- 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；

- 视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；
- 新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；

- 比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；
- DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。



# 同源策略

如果两个URL协议、域名和端口都相同，就称这两个URL同源。浏览器默认两个相同的源之间是可以相互访问资源和操作DOM的。刻个不同的源之间若想要相互访问资源或者操作DOM，那么会有一套基础的安全策略的制约，就是同源策略。



## DOM层面

同源策略限制了来自不同源的JavaScript脚本对当前DOM对象读和写的操作。

例如：在window A中打开了window B 页面，B.opener 指向A页面的window对象。。如果window A 和 B 是同源页面，那么可以在B页面控制A页面的DOM。

```javascript
let pdom = opener.document
pdom.body.style.display = "none"
```

## 数据层面

同源策略限制了不同源的站点读取当前站点的Cookie、IndexDB、LocalStorage等数据。由于同源策略，无法通过第二个页面的opener来访问第一个页面找那个的Cookie等内容。



## 网络层面

同源策略限制了通过XMLHttpRequest等方式将站点的数据发送给不同源的站点。



### 安全和便利性的权衡

让不同源之间绝对隔离，会让Web项目难以开发和使用。因此浏览器为了一些灵活性会出让一些同源策略的安全性限制

### 1.页面中可以嵌入第三方资源

这样会存在XSS攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。

### 2.跨域资源共享和跨文件消息

CORS 和 window.postMessage





# 跨站脚本攻击（XSS）

XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。



当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。

如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情：

- 可以窃取 Cookie 信息。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
- 可以监听用户行为。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。

- 可以通过修改 DOM 伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
- 还可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。



## 恶意脚本是怎么注入的

### 存储型XSS攻击

![img](https://cdn.nlark.com/yuque/0/2022/png/21510703/1641121538608-3180aaa7-ba50-4aed-82d5-1abe3184b1b4.png)

- 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
- 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；

- 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。



### 反射型XSS攻击

在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作（例如QQ、邮箱等渠道发出的链接）。

Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。



### 基于DOM的XSS攻击

基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。



## 如何阻止XSS攻击



- 服务器对输入脚本进行过滤或转码

- - 将script标签中的内容过滤掉、或者对内容进行转码。

- 充分利用CSP（内容安全策略）

- - 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
  - 禁止向第三方域提交数据，这样用户数据也不会外泄；

- - 禁止执行内联脚本和未授权的脚本；
  - 提供上报机制。及时修复问题。

- 使用HttpOnly属性

- - 服务器将某些Cookie设置HttpOnly属性



# CSRF攻击

CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。

![img](https://cdn.nlark.com/yuque/0/2022/png/21510703/1641191375595-aa48b648-e4ce-47d8-a6fd-e1bea4dcc54f.png)



## 攻击方式

### 自动发起Get请求

黑客页面的代码中可以将Get请求接口隐藏到img标签中，欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器就会自动发起img的资源请求。

```html
<!DOCTYPE html>
<html>
  <body>
    <h1>黑客的站点</h1>
    <img src="XXX">
  </body>
</html>
```

### 自动发起POST请求

比如设置一个自动提交的隐藏表单

```html
<!DOCTYPE html>
<html>
<body>
  <h1>黑客的站点</h1>
  <form id='hacker-form' action="XXX" method=POST>
    <input type="hidden" name="user" value="hacker" />
    <input type="hidden" name="number" value="100" />
  </form>
  <script> document.getElementById('hacker-form').submit(); </script>
</body>
</html>
```

### 引诱用户点击链接

这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接。



## 如何防止CSRF攻击

CSRF攻击的必要条件

- 第一个，目标站点一定要有 CSRF 漏洞；
- 第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；

- 第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。

与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。



### 充分利用好Cookie的SameSite属性

通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：

- 如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器；
- 如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。



在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项

SameSite 选项通常有 Strict、Lax 和 None 三个值。

- Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。
- Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。

- 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。



### 验证请求的来源站点

由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。

Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。通过Referer字段可以对站点进行判断。

但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性。

Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。Origin 的值之所以不包含详细路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。



### CSRF Token

第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。

第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。



# 安全沙箱

通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。

![img](https://cdn.nlark.com/yuque/0/2022/png/21510703/1641255258986-8d1ccd75-1853-46ba-ad8b-832249652cf8.png)

浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。

所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。



**将渲染进程和操作系统隔离就是安全沙箱技术。**

浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。

安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。

安全沙箱需要应用在没有读写操作系统功能的进程上。

![img](https://cdn.nlark.com/yuque/0/2022/png/21510703/1641255716519-39d13e48-7d1b-41e4-94d6-7ee1a777aba8.png)



## 安全沙箱如何影响到各个模块功能呢？

### 持久存储

由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。

- 存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。
- 一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。



### 网络访问

有了安全沙箱的保护，在渲染进程内部是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。



### 用户交互

在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。

由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。

- 第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。
- 第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程。



### 站点隔离

所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关联的页面放到同一个渲染进程中执行。

实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。



# HTTPS：让数据更安全

HTTP的明文传输容易受到中间人攻击。

在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。

![img](https://cdn.nlark.com/yuque/0/2022/png/21510703/1641340161583-f80f3341-ee2e-4ab6-937f-559909bfd63e.png)



## 在HTTP协议栈中引入安全层

![img](https://cdn.nlark.com/yuque/0/2022/png/21510703/1641340317581-0c0a259b-057e-4385-911e-edde1590b150.png)

可以在TCP和HTTP之间插入一个安全层，所有经过安全层的数据都会被加密或者解密。HTTPS先和安全层通信，然后安全层再和TCP层通信。也就是说HTTPS所有的安全核心都在安全层，它不会影响到上面的HTTP协议，也不会影响到下面的TCP/IP。

总的来说，安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。



## 对称加密和非对称加密搭配使用

![img](https://cdn.nlark.com/yuque/0/2022/png/21510703/1641340637103-70be2381-cb2f-431b-843b-1919a1db0887.png)



- 首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；
- 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；

- 浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；
- 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。

- 服务器和浏览器有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。
- 有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。

pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。



## 添加数字证书

对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。

颁发数字证书（Digital Certificate）的机构称为CA（Certificate Authority）

![img](https://cdn.nlark.com/yuque/0/2022/png/21510703/1641340884892-9549eac7-363b-4f85-91ab-67f6514afb79.png)



- 服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；
- 在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。



## 浏览器如何验证数字证书

浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的。

这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它，然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。

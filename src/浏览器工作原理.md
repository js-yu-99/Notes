# 为什么打开一个页面，任务管理器中会有四个进程？

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638691885866-f37dc7b9-f499-4a1c-8eb8-b78c152b87b8.png)



## 进程和线程

### 什么是并行处理

计算机中的并行处理就是同一时刻处理多个任务。

```javascript
A = 1+2;
B = 20/5;
C = 7*8
```

在编写代码的时候，我们可以把这个过程拆分为四个任务：

- 任务 1 是计算 A=1+2；
- 任务 2 是计算 B=20/5；

- 任务 3 是计算 C=7*8；
- 任务 4 是显示最后计算的结果。

单线程来处理的时候，按照任务顺序分别执行这四个任务；

多线程处理的时候，分两步走：第一步，使用三个线程同事执行前三个任务；第二步，再执行第四个显示任务。

所以并行处理能大大提高性能。



### 线程 VS 进程

线程不能单独存在，是由进行来启动和管理的。一个进程就是一个程序的运行实例。

启动一个程序的时候，操作系统会被该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境叫进程。

**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。**



进程和线程关系之间的特点：

- 进程中的任意一线程执行出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据

- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离



## 单进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638695013003-029877e3-bf6f-429a-b3ac-2964305009d6.png)

浏览器所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。如此多的功能模块运行在一个进程里，导致单进程浏览器不稳定、不流畅和不安全。

### 不稳定

web端的视频和游戏需要借助插件来实现各种功能，但是插件容易出现问题，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。

一些复杂的JavaScript代码也可能引起渲染引擎模块的崩溃。

### 不流畅

```javascript
function freeze() { while (1) { console.log("freeze"); }}freeze();
```

浏览器同一时刻只能有一个模块在运行。

当代码中有一段无限循环的代码时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。这样就会导致整个浏览器失去响应，变卡顿。

页面的内存泄露也会导致单进程变慢。

### 不安全

插件和脚本代码可以通过获取系统权限对电脑做出恶意的事情，引发安全问题



## 多进程浏览器

### 早起的多进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638695788856-965323dd-7c10-4d5b-ae37-81dcd80d42e1.png)

Chrome的页面是运行在单独的渲染进程中的，同事页面里的插件也是运行在单独的插件进程之中，而进程之间是通过IPC机制进行通信。

#### 如何解决不稳定？

由于进程之间是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或插件进程，并不会影响到浏览器和其他页面。

#### 如何解决不流畅？

JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面。不会影响到浏览器和其他页面。

#### 如何解决不安全？

采用多进程架构就可以使用安全沙箱，沙箱可以看做是操作系统给进程上的一把锁，沙箱里的程序不会营销到沙箱外的数据、程序、系统等。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。



### 当前的多进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638696677635-448e15c5-0f67-482f-bbc0-b68bf9321bba.png)



> 最新的Chrome浏览器包括：1个浏览器（Browser）进程、1个GPU进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。

- 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页。排版引擎Blink和JavaScript引擎V8都是运行在该进程中，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

>  打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

### 多线程浏览器的问题

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。



> Chrome的默认策略：每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。



# TCP协议：保证页面文件能被完整送达浏览器

## 一个数据包的旅程

### IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合网际协议（IP）标准。计算机地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

- 将客户端主机上的数据包交给网络层
- 网络层再将包含客户端主机和服务端主机地址等信息的IP头附加到数据包上，组成新的IP数据包，并交给后面几个层级。

- 最后通过物理网络将数据包传输到服务端主机。
- 数据包被传输到服务端主机的网络层，在这里服务端拆开数据包的IP头信息，并将拆开来的数据部分交给上层；

- 最终，含有指定信息的数据包就到达了服务端主机的上层。



### UDP：把数据包送达应用程序

IP传输只能将数据包发送到对方电脑，但是却并不知道具体交给哪个程序。这时，便用到了基于IP协议开发的能和应用打交道的协议，较为常见的就是UDP（用户数据包协议）

UDP中一个最重要的信息是端口号，端口号其实就是一个数字，每个访问网络的程序都需要绑定一个端口号。通过端口号UDP秋恩能够把指定的数据包发送给指定的程序了。所以IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。

但是在使用UDP发送数据时，有各种因素会导致数据包出错，并且不提供错误重发机制，只是丢弃当前的包，而且UDP发送后也无法知道是否能到达目的地。

搜索UDP不能保证数据可靠性，但是传输速度非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。



### TCP：把数据完整的送达应用程序

UDP传输往往面临两个问题：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDO协议并不知道如何组装这些数据包，从而把这些数据宝还原成完整的文件。



而使用TCP（传输控制协议）协议有两个特点：

- 对于数据包丢失的情况，TCP提供重传机制；
- TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638802834428-ae455888-4f43-4de5-988a-6db36ed01445.png)



- 首先，建立连接阶段。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- 其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

- 最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

所以TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度。



# HTTP请求流程

## 浏览器发起HTTP请求流程

### 1.构建请求

```javascript
GET /index.html HTTP1.1
```

### 2.查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。

当浏览器发现请求的资源存在缓存时，它会拦截请求，返回该字眼的缓存，并直接结束请求，而不会再去源服务器重新下载。

使用缓存的好处：

- 缓解服务器端压力，提升性能；
- 对于网站来说，缓存是实现快速资源加载的重要组成部分。

如果查找失败，就会进入网络请求过程。

### 3.准备IP地址和端口

浏览器会请求DNS（域名系统）返回域名对应的IP。DNS同样存在缓存，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用。

拿到IP后，获取端口号，通常情况下，URL默认端口号为80端口。



### 4.等待TCP队列

Chrome浏览器机制规定同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下有10个请求发生，那么其中4个请求会进入排队等候状态，直至进行中的请求完成。



### 5.建立TCP连接

TCP三次握手建立连接



### 6.发送HTTP请求

浏览器会向服务器发送请求行，包括了请求方法、请求URI和HTTP版本协议。请求头中包括一些其他信息，比如cookie、host等信息。



## 服务器端处理HTTP请求流程

### 1.返回请求

服务器返回响应行（包括协议版本和状态码）、响应头、响应体。



### 2.断开连接

默认情况下，一旦服务器向客户端返回了请求数据后，就要关闭TCP连接，如果浏览器或者服务器在其头部信息中加入Connection:Keep-Alive，那么TCP就会保持打开状态，保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。



### 3.重定向



## 为什么很多站点第二次打开速度会很块？

如果第二次页面打开的很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。比如DNS缓存和浏览器缓存。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638886887145-f549909a-9883-4472-a393-871929faaa8e.png)



当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的。

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：If-None-Match:"4f80f-13c-3a1xb12a"。服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”如果资源有更新，服务器就直接返回最新资源给浏览器。

简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。



## 登录状态是如何保持的？

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638887017902-b82fb421-5dd9-476d-baf4-a10199e9901a.png)


# 为什么打开一个页面，任务管理器中会有四个进程？

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638691885866-f37dc7b9-f499-4a1c-8eb8-b78c152b87b8.png)



## 进程和线程

### 什么是并行处理

计算机中的并行处理就是同一时刻处理多个任务。

```javascript
A = 1+2;
B = 20/5;
C = 7*8
```

在编写代码的时候，我们可以把这个过程拆分为四个任务：

- 任务 1 是计算 A=1+2；
- 任务 2 是计算 B=20/5；

- 任务 3 是计算 C=7*8；
- 任务 4 是显示最后计算的结果。

单线程来处理的时候，按照任务顺序分别执行这四个任务；

多线程处理的时候，分两步走：第一步，使用三个线程同事执行前三个任务；第二步，再执行第四个显示任务。

所以并行处理能大大提高性能。



### 线程 VS 进程

线程不能单独存在，是由进行来启动和管理的。一个进程就是一个程序的运行实例。

启动一个程序的时候，操作系统会被该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，这样的一个运行环境叫进程。

**线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。**



进程和线程关系之间的特点：

- 进程中的任意一线程执行出错，都会导致整个进程的崩溃
- 线程之间共享进程中的数据

- 当一个进程关闭之后，操作系统会回收进程所占用的内存
- 进程之间的内容相互隔离



## 单进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638695013003-029877e3-bf6f-429a-b3ac-2964305009d6.png)

浏览器所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。如此多的功能模块运行在一个进程里，导致单进程浏览器不稳定、不流畅和不安全。

### 不稳定

web端的视频和游戏需要借助插件来实现各种功能，但是插件容易出现问题，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。

一些复杂的JavaScript代码也可能引起渲染引擎模块的崩溃。

### 不流畅

```javascript
function freeze() { while (1) { console.log("freeze"); }}freeze();
```

浏览器同一时刻只能有一个模块在运行。

当代码中有一段无限循环的代码时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。这样就会导致整个浏览器失去响应，变卡顿。

页面的内存泄露也会导致单进程变慢。

### 不安全

插件和脚本代码可以通过获取系统权限对电脑做出恶意的事情，引发安全问题



## 多进程浏览器

### 早起的多进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638695788856-965323dd-7c10-4d5b-ae37-81dcd80d42e1.png)

Chrome的页面是运行在单独的渲染进程中的，同事页面里的插件也是运行在单独的插件进程之中，而进程之间是通过IPC机制进行通信。

#### 如何解决不稳定？

由于进程之间是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或插件进程，并不会影响到浏览器和其他页面。

#### 如何解决不流畅？

JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面。不会影响到浏览器和其他页面。

#### 如何解决不安全？

采用多进程架构就可以使用安全沙箱，沙箱可以看做是操作系统给进程上的一把锁，沙箱里的程序不会营销到沙箱外的数据、程序、系统等。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。



### 当前的多进程浏览器

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638696677635-448e15c5-0f67-482f-bbc0-b68bf9321bba.png)



> 最新的Chrome浏览器包括：1个浏览器（Browser）进程、1个GPU进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。

- 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页。排版引擎Blink和JavaScript引擎V8都是运行在该进程中，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

- 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

>  打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。

### 多线程浏览器的问题

- 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。



> Chrome的默认策略：每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。



# TCP协议：保证页面文件能被完整送达浏览器

## 一个数据包的旅程

### IP：把数据包送达目的主机

数据包要在互联网上进行传输，就要符合网际协议（IP）标准。计算机地址就称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

- 将客户端主机上的数据包交给网络层
- 网络层再将包含客户端主机和服务端主机地址等信息的IP头附加到数据包上，组成新的IP数据包，并交给后面几个层级。

- 最后通过物理网络将数据包传输到服务端主机。
- 数据包被传输到服务端主机的网络层，在这里服务端拆开数据包的IP头信息，并将拆开来的数据部分交给上层；

- 最终，含有指定信息的数据包就到达了服务端主机的上层。



### UDP：把数据包送达应用程序

IP传输只能将数据包发送到对方电脑，但是却并不知道具体交给哪个程序。这时，便用到了基于IP协议开发的能和应用打交道的协议，较为常见的就是UDP（用户数据包协议）

UDP中一个最重要的信息是端口号，端口号其实就是一个数字，每个访问网络的程序都需要绑定一个端口号。通过端口号UDP秋恩能够把指定的数据包发送给指定的程序了。所以IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。

但是在使用UDP发送数据时，有各种因素会导致数据包出错，并且不提供错误重发机制，只是丢弃当前的包，而且UDP发送后也无法知道是否能到达目的地。

搜索UDP不能保证数据可靠性，但是传输速度非常快，所以UDP会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。



### TCP：把数据完整的送达应用程序

UDP传输往往面临两个问题：

- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDO协议并不知道如何组装这些数据包，从而把这些数据宝还原成完整的文件。



而使用TCP（传输控制协议）协议有两个特点：

- 对于数据包丢失的情况，TCP提供重传机制；
- TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638802834428-ae455888-4f43-4de5-988a-6db36ed01445.png)



- 首先，建立连接阶段。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- 其次，传输数据阶段。在该阶段，接收端需要对每个数据包进行确认操作，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。

- 最后，断开连接阶段。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

所以TCP为了保证数据传输的可靠性，牺牲了数据包的传输速度。



# HTTP请求流程

## 浏览器发起HTTP请求流程

### 1.构建请求

```javascript
GET /index.html HTTP1.1
```

### 2.查找缓存

在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。

当浏览器发现请求的资源存在缓存时，它会拦截请求，返回该字眼的缓存，并直接结束请求，而不会再去源服务器重新下载。

使用缓存的好处：

- 缓解服务器端压力，提升性能；
- 对于网站来说，缓存是实现快速资源加载的重要组成部分。

如果查找失败，就会进入网络请求过程。

### 3.准备IP地址和端口

浏览器会请求DNS（域名系统）返回域名对应的IP。DNS同样存在缓存，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用。

拿到IP后，获取端口号，通常情况下，URL默认端口号为80端口。



### 4.等待TCP队列

Chrome浏览器机制规定同一个域名同时最多只能建立6个TCP连接，如果在同一个域名下有10个请求发生，那么其中4个请求会进入排队等候状态，直至进行中的请求完成。



### 5.建立TCP连接

TCP三次握手建立连接



### 6.发送HTTP请求

浏览器会向服务器发送请求行，包括了请求方法、请求URI和HTTP版本协议。请求头中包括一些其他信息，比如cookie、host等信息。



## 服务器端处理HTTP请求流程

### 1.返回请求

服务器返回响应行（包括协议版本和状态码）、响应头、响应体。



### 2.断开连接

默认情况下，一旦服务器向客户端返回了请求数据后，就要关闭TCP连接，如果浏览器或者服务器在其头部信息中加入Connection:Keep-Alive，那么TCP就会保持打开状态，保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。



### 3.重定向



## 为什么很多站点第二次打开速度会很块？

如果第二次页面打开的很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。比如DNS缓存和浏览器缓存。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638886887145-f549909a-9883-4472-a393-871929faaa8e.png)



当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的。

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：If-None-Match:"4f80f-13c-3a1xb12a"。服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”如果资源有更新，服务器就直接返回最新资源给浏览器。

简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。



## 登录状态是如何保持的？

如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638887017902-b82fb421-5dd9-476d-baf4-a10199e9901a.png)

### 

# 从输入URL到页面展示，这中间发生了什么？

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638973455758-9674a5e1-c53f-4392-9412-85195e5d15bd.png)

- 浏览器进程主要负责用户交互、子进程管理和文件存储等功能。
- 网络进程是面向渲染过程和浏览器进程等提供网络下载功能。

- 渲染进程的主要职责是把从网络下载的HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。



## 从输入URL到页面展示

### 1.用户输入

地址栏会判断用户输入的关键字是搜索内容还是请求的URL。

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
- 如果判断输入内容符合URL规则，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL。

当用户输入关键字并回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行`beforeunload`事件的机会，`beforeunload`事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未计较完成的表单等情况，因此用户可以通过`beforeunload`事件来取消导航，让浏览器不再执行任何后续工作。

当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时页面现实的依然是之前打开的页面内容，并没有立即替换为新页面。因为需要等待提交文档阶段，页面内容才会被替换。



### 2.URL请求过程

浏览器进程通过`进程间通信（IPC）`把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程。

首先网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。请求前的第一步是要进行DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，那么还需要建立TLS连接。

接下来利用IP地址和服务器建立TCP连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。

服务器接收到请求信息后，会根据请求信息生成相应数据，并发送给网络进程。网络进程会解析响应头的内容。

如果网络进程发现反馈的状态码是301或者302，那么说明浏览器需要重定向到其他URL。这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再次发起请求，重头开始。

如果返回200，那么表示浏览器可以继续处理该请求。

#### 响应数据类型处理

Content-Type是HTTP头中一个非常重要的字段，它告诉浏览器服务器返回的响应体数据时什么类型，然后浏览器会根据Content-Type的值来决定如何显示响应体的内容。

- text/html ： HTML格式
- text/plain ：纯文本格式

- text/xml ： XML格式
- image/gif ：gif图片格式

- image/jpeg ：jpg图片格式
- image/png：png图片格式

- application/xhtml+xml ：XHTML格式
- application/xml： XML数据格式

- application/atom+xml ：Atom XML聚合格式
- application/json： JSON数据格式

- application/pdf：pdf格式
- application/msword ： Word文档格式

- application/octet-stream ： 二进制流数据（如常见的文件下载）
- application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）



### 3.准备渲染过程

默认情况下，Chrome会每打开一个新页面就配套创建一个新的渲染进程。

如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一个站点的话，那么新页面会复用父页面的渲染进程。（process-per-site-instance）

同一站点定义为根域名加上协议，还包括该根域名下的所有子域名和不同的端口。



### 4.提交文档

浏览器进程将网络进程接收道德HTML数据提交给渲染进程，具体流程为：

- 首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息。
- 渲染进程接收到提交文档的消息后，会和网络进程建立传输数据的管道。

- 等文档数据传输完成之后，渲染进程会返回确认提交的消息会浏览器进程。
- 浏览器进程在收到确认提交的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。



### 5.渲染阶段



# 渲染流程

HTML 超文本标记语言 由标记和文本组成。标记也称为标签，每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容

CSS 又称为层叠样式表，是由选择器和属性组成。
JavaScript，使用它可以使网页的内容“动”起来。

把一个处理HTML、CSS、JS的流程称为渲染流水线。其中包含多个子阶段。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063165196-30c3a478-b8f2-45f8-9ab0-5cd57cacfb32.png)



按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。



## 构建 DOM 树

因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063253728-7618dc32-6f7b-4b42-bc28-460fc32a9d47.png)

构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。

## 样式计算（Recalculate Style）

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。

### 1.把 CSS 转换为浏览器能够理解的结构

CSS 样式来源主要有三种：

- 通过 link 引用的外部 CSS 文件
- <style>标记内的 CSS

- 元素的 style 属性内嵌的 CSS

浏览器也无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063405290-bb0da27e-a27d-42e6-b5df-33bc5f9a10ed.png)



### 2.转换样式表中的属性值，使其标准化

```css
body { font-size: 2em }
p {color:blue;}
span  {display: none}
div {font-weight: bold}
div  p {color:green;}
div {color:red; }
```

CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063497291-5c14eba4-119f-4c6d-a276-5eaf942c400d.png)



### 3.计算出 DOM 树中每个节点的具体样式

> CSS 会继承父级节点的样式。

常用可继承属性：

1. 字体系列属性：font-family，font-size

2. 文本系列属性：text-indent，line-height，color

3. 元素可见性：visibility

4. 表格布局属性：border-style

5. 列表布局属性：list-style list-style-type

6. 光标属性：cursor

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063636675-7853d514-6850-4484-b07f-e7f016a8e685.png)



> 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。



## 布局阶段

计算出 DOM 树中可见元素的几何位置的计算过程，叫做布局。

### 1. 创建布局树

DOM中存在不少不可见节点，比如**head标签、script标签、使用display:none的元素**。在显示之前，还要额外地构建一棵只包含可见元素布局树。

为了构建布局树，浏览器大体上完成了下面这些工作：遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；而不可见的节点会被布局树忽略掉。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639063929804-5709025c-e42e-4576-afd9-7b0731c34722.png)

### 2. 布局计算



## 分层

页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114266076-31cd4627-04d5-45c3-8a94-56aa31b5a70f.png)

浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114324617-f7d607de-4486-4383-847f-aba1044eafb4.png)

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

满足以下两点的元素会被提升为单独的一个图层：

### 1.拥有层叠上下文属性的元素会被提升为单独的一层。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639114402705-028af40b-0411-4c02-8435-b5cba4c26dc9.png)

明确定位属性的元素、定义透明属性的元素、使用css滤镜的元素等，都拥有层叠上下文属性。



### 2.需要剪裁（clip）的地方也会被创建为图层。

固定大小的元素内，内容过长会出现裁剪。渲染引擎会把裁剪文字内容的一部分用于显示在元素区域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639220143431-15a02a20-1bf3-4d15-a88c-ba55905ceda6.png)





## 图层绘制

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

在图层绘制阶段，输出的就是这些待绘制列表。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639220355573-5fcb0723-396a-4307-8ea6-5c3d824feadb.png)



## 栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。

浏览器不会一次绘制出所有图层的内容，只会绘制当前可视窗口的内容。基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639221484771-841ba4e1-933b-45f9-a5e6-629a5532e17a.png)



## 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。





![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639221740082-c280578b-c5ec-4e44-822e-00a610ba84d9.png)

**一个完整的渲染流程大致可为：**

1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

1. 创建布局树，并计算元素的布局信息。
2. 对布局树进行分层，并生成分层树。

1. 为每个图层生成绘制列表，并将其提交到合成线程。
2. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。

1. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
2. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。



## 更新了元素的几何属性（重排）

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639222463479-00d70cf7-7229-4269-bec5-7a51c76efbd4.png)



如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。重排需要更新完整的渲染流水线，所以开销也是最大的。



## 更新元素的绘制属性（重绘）

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639222513286-a9f2ed9f-fb45-4247-b307-8d9b9529f807.png)

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。



## 直接合成阶段

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639222548440-06229c90-5c04-4c75-9160-f2a18de48c64.png)

使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。



## 减少重排重绘的方法



- 使用 class 操作样式，而不是频繁操作 style
- 避免使用 table 布局

- 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
- Debounce window resize 事件

- 对 dom 属性的读写要分离
- will-change: transform 做优化
- 等等



# 变量提升

- 在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。
- 在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。

- 在一个函数定义之前使用它，不会出错，且函数能正确执行。

>  所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值 undefined。

## JavaScript 代码的执行流程

变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639317427890-e8534e38-0e04-4d9f-8849-8ff6ad78d8bd.png)

### 1.编译阶段

```javascript
showName();
console.log(name);
var name = 'wangyu';
function showName() {
	console.log('函数执行');
}

// 变量提升
var name = undefined;
function showName() {
	console.log('函数执行');
}

// 执行部分
showName();
console.log(name);
name = 'wangyu';
```

输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。

执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。

在执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容，比如name、showName，都保存在该对象中。



### 2.执行阶段

- 当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出结果。
- 接下来打印“name”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 name 变量，并且其值为 undefined，所以这时候就输出 undefined。

- 接下来，把“wangyu”赋给 name 变量，赋值后变量环境中的 name 属性值改变为“wangyu”



## 代码中出现相同的变量或者函数怎么办？

```javascript
function showName() {
    console.log('wangyu');
}
showName(); // jiangyu
function showName() {
    console.log('jiangyu');
}
showName(); // jiangyu
```

- 首先是编译阶段。遇到了第一个 showName 函数，会将该函数体存放到变量环境中。接下来是第二个 showName 函数，继续存放至变量环境中，但是变量环境中已经存在一个 showName 函数了，此时，第二个 showName 函数会将第一个 showName 函数覆盖掉。这样变量环境中就只存在第二个 showName 函数了。
- 接下来是执行阶段。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数，打印的内容是“jiangyu”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“jiangyu”。



所以一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。





# 为什么JavaScript会出现栈溢出？

## 什么是栈？

一条单车道的单行线，一端被堵住了，而另一端入口处没有任何提示信息，堵住之后就只能后进去的车子先出来，这时这个堵住的单行线就可以被看作是一个栈容器，车子开进单行线的操作叫做入栈，车子倒出去的操作叫做出栈。

在车流量较大的场景中，就会发生反复的入栈、栈满、出栈、空栈和再次入栈，一直循环。

所以，栈就是类似于一端被堵住的单行线，车子类似于栈中的元素，栈中的元素满足后进先出的特点。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396242941-0fb3d773-06e8-45c9-9a09-ef91e5f073e0.png)



## 什么是JavaScript调用栈

JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称**调用栈**。

```javascript
var a = 2
function add(b,c){
  return b+c
}
function addAll(b,c){
var d = 10
result = add(b,c)
return  a+result+d
}
addAll(3,6)
```

执行这段代码时：

**第一步，创建全局上下文，并将其压入栈底**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396346889-d6b5390e-fa3b-4437-9139-077295e71bc7.png)

全局执行上下文入栈以后，JavaScript引擎就开始执行全局代码了。首先执行a = 2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。



**第二步是调用addAll函数**

当调用该函数时，JavaScript引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396470177-cf0c739d-6d29-4561-95ed-30d84a985975.png)



**第三步，执行add函数**

同样 JavaScript引擎会为其创建执行上下文，并将其压入调用栈。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396515810-86fc038a-7a1f-43d2-a463-ee85daa77bd2.png)

当add函数执行完后，add的执行上下文出栈，当addAll函数执行完成后，addAll的执行上下文也会从栈顶弹出，只留下全局执行上下文。



利用浏览器来查看调用栈的信息。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639396621571-6c67d1a1-6e78-41cb-8c1b-d203e051ccc1.png)



## 栈溢出

调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript引擎就会报错，这种错误就是栈溢出。

```javascript
function division(a,b){
    return division(a,b)
}
console.log(division(1,2)) // Maximum call stack size exceeded
```

当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。



# 块级作用域

## 作用域（scope）

作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。

- 全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。



块级作用域则是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句等都可以看做是块级作用域。

```javascript
if (true) {}

function foo() {}

while(true) {}

{}

for () {}

try {} catch {}
```

## 变量提升所带来的问题

1. 变量容易在不被察觉的情况下被覆盖掉

```javascript
var myname = "wangyu"
function showName(){
  console.log(myname); // undefined
  if(0){
   var myname = "jiangyu"
  }
  console.log(myname); // undefined
}
showName()

// showName函数内容有var声明的变量，导致会在编译时存在变量提升。
```

1. 本应销毁的变量没有被销毁

```javascript
function foo(){
  for (var i = 0; i < 7; i++) {
  }
  console.log(i); // 7  因为变量i在foo函数作用域内变量提升，所以i++的赋值一直都是同一个i变量
}
foo()
```

## let 和 const

```javascript
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

**第一步 编译并创建执行上下文**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639494287485-52ecfdf8-dc07-4c6a-a37a-0dc33b4668cd.png)

let声明的变量会被存放到词法环境中，而var声明的变量被存放到变量环境中，不过此时在函数作用域内的块级作用域内，通过let声明的变量并没有被存放到词法环境中。



**第二步 继续执行代码**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639494427514-5b25e663-a43b-4a5a-b20c-ba2ddb8a58fd.png)

当代码执行到函数内块级作用域里面的时候，let声明的变量会被存放到词法环境的一个单独的区域中，这个区域中的变量不会影响到块级作用域外面的变量。比如函数内部的两个b变量，是独立存在的、互不影响的。

词法环境也是一个栈结构，占地是函数最外层的变量，进入一个块级作用域，就会把该作用域内部的变量压到栈顶。当作用域执行完成之后，该作用域的信息就会从栈顶弹出。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639494627544-bd37da44-dbf4-4d83-b0e9-33ca4308adbd.png)



# 作用域链和闭包

```javascript
function bar() {
    console.log(myName) // wangyu
}
function foo() {
    var myName = "jiangyu"
    bar()
}
var myName = "wangyu"
foo()

// 为什么打印的是“wangyu”?
```

## 作用域链

在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，把这个外部引用称为 outer。

当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量。

bar函数和foo函数的outer都是指向全局上下文的，这也就意味着如何在bar函数或者foo函数中使用了外部变量，那么JavaScript引擎会去全局执行上下文中查找。这种查找的链条就是作用域链。



## 词法作用域

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639579048709-c5cc1262-5d04-4ad6-9cf1-f7baf781363a.png)

从图中可以看出，词法作用域就是根据代码的位置来决定的，其中 main 函数包含了 bar 函数，bar 函数中包含了 foo 函数，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—>bar 函数作用域—>main 函数作用域—> 全局作用域。



根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。

```javascript
function bar() {
    var myName = "yu1"
    let test1 = 100
    if (1) {
        let myName = "yu2"
        console.log(test); // 1
      	console.log(myName); // yu2
    }
}
function foo() {
    var myName = "yu3"
    let test = 2
    {
        let test = 3
        bar()
    }
}
var myName = "yu4"
let myAge = 10
let test = 1
foo()
```



## 闭包

```javascript
function foo() {
    var myName = "wangyu"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("jiangyu")
bar.getName()
console.log(bar.getName())
```

根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量。所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。

foo函数执行完之后，其执行上下文从栈顶弹出，但是由于myName和test1变量还被bar所引用，所以这两个变量依然保存在内存中。



在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1639580682200-83b7fe70-85c2-4a21-a5b7-d2d11ed23448.png)



## 闭包是怎样回收的？

如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。



# this

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640083534364-2d9c0517-5af6-48fc-84dc-2da56dfa1969.png)

在JavaScript中，this是和执行上下文绑定的，每个执行上下文都有一个this。



全局执行上下文中的this指向的是window对象。

全局上下文中调用的函数中的this，默认也是window对象。

## 设置函数执行上下文中的this值。

### 1.通过函数的call方式设置。

```javascript
var bar = {
  myName : "wangyu",
  test1 : 1
}
function foo(){
  this.myName = "jiangyu"
}
foo.call(bar)
console.log(bar) // {myName: jiangyu, ...}
console.log(myName) // 未定义
```

### 2.通过对象调用方法设置

```javascript
var myObj = {
  name : "wangyu", 
  showThis: function(){
    console.log(this)
  }
}
myObj.showThis() // wangyu
```

### 3.通过构造函数中设置

```javascript
function CreateObj(){
  this.name = "wangyu"
}
var myObj = new CreateObj()
```

当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：

- 首先创建了一个空对象 tempObj；
- 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；

- 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；
- 最后返回 tempObj 对象。



## this的设计缺陷及应对方案

### 1.嵌套函数中的this不会从外层函数中继承

```javascript
var myObj = {
  name : "wangyu", 
  showThis: function(){
    console.log(this) // mObj
    function bar(){console.log(this)} // window
    bar()
  }
}
myObj.showThis()

// showThis函数中可以用一个变量保存this。然后在bar函数中使用
showThis: function(){
  console.log(this)
  var self = this
  function bar(){
    self.name = "11"
  }
  bar()
}

// 使用箭头函数，箭头函数不会创建其自身的执行上下文。
// 所以箭头函数中的this取决于它的外部函数。
showThis: function(){
  console.log(this)
  var bar = ()=>{
    this.name = "22"
    console.log(this)
  }
  bar()
}
```

### 2.普通函数中的this默认指向全局对象window

可添加严格模式，其函数的执行上下文中的this值是undefined。



# 消息队列和事件循环

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640185215076-6307ceff-b365-423a-8370-10a1022f738e.png)

渲染进程专门有一个IO线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务放入消息对象发送给主线程。主线程在空闲时会通过事件循环依次取出消息队列中的任务执行。

消息队列中的任务类型包括输入事件、微任务、文件读写、WebSocket、JavaScript定时器等，还包括JavaScript执行、解析DOM、样式计算、布局计算、CSS动画等。



当页面主线程执行完成之后，Chrome确认要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志，如果设置了，那么就直接中断当前的所有任务，退出线程。

## 页面使用单线程的缺点

**第一个问题是如果处理高优先级的任务**

如果此时需要存在一个能力，监听DOM节点的变化情况，那么此时，如果每次DOM变化同步调用对应接口，那么在DOM变更过于频繁的时候，会阻塞其他事件进行，而如果采用异步的方式，监听时的时间不精准。

这种情况下，出现了微任务，微任务会在当前宏任务执行完后执行。这样，监听的实时性就大大提高。



**第二个问题是单个任务执行时长过久**

这种情况下应该通过回调功能来规避此类问题



# setTimeout

[MDN-setTimeout](https://developer.mozilla.org/zh-CN/docs/Web/API/setTimeout)

setTimeout是一个定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。setTimeout的执行最小间隔为4毫秒。

```javascript
function showName(){
  console.log("start")
}
var timerID = setTimeout(showName,200);
clearTimeout(timerID);
```

在Chrome中除了正常使用的消息队列之外，还有另外一个消息队列（hashmap结构），这个队列中维护了需要延时执行的任务列表，包括了定时器和Chromium内部以下需要延迟执行的任务。所以当通过JavaScript创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。

当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数、当前发起时间、延迟执行时间。创建好回调任务之后，再将该任务添加到延迟执行队列中。

消息队列中的任务执行完之后，就是去执行延迟队列中到期的任务。

## 使用setTimeout的一些注意事项

- 如果当前任务执行时间过久，会影响定时器任务的执行。
- 如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4毫秒。

- - 因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。

```javascript
function cb() { setTimeout(cb, 0); }
setTimeout(cb, 0);
```

- 未激活的页面，setTimeout执行最小间隔是1000毫秒。
- 延迟执行时间有最大值。

- - Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。

- 使用setTimeout时回调函数中的this指向问题

- - 如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。

```javascript
var name= 1;
var MyObj = {
  name: 2,
  showName: function(){
    console.log(this.name); // 1
  }
}
setTimeout(MyObj.showName,1000);

// 解决办法

//箭头函数
setTimeout(() => {
    MyObj.showName()
}, 1000);
//或者function函数
setTimeout(function() {
  MyObj.showName();
}, 1000)

// bind
setTimeout(MyObj.showName.bind(MyObj), 1000)
```



# XMLHttpRequest

XMLHttpRequest提供了从web服务器获取数据的能力。

## 系统调用栈

当循环系统在执行一个任务的时候，都会为这个任务维护一个系统调用栈。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640351083047-f9ee1959-3fd5-4623-acae-9968b22c645a.png)

黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。通过该图可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。

整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。



## XMLHttpRequest运行机制

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1640351264910-b2b653cf-ed24-44c0-a64f-27262a7564b6.png)

```javascript
 function GetWebData(URL){
    /**
     * 1:新建XMLHttpRequest请求对象
     */
    let xhr = new XMLHttpRequest()

    /**
     * 2:注册相关事件回调处理函数 
     */
    xhr.onreadystatechange = function () {
        switch(xhr.readyState){
          case 0: //请求未初始化
            console.log("请求未初始化")
            break;
          case 1://OPENED
            console.log("OPENED")
            break;
          case 2://HEADERS_RECEIVED
            console.log("HEADERS_RECEIVED")
            break;
          case 3://LOADING  
            console.log("LOADING")
            break;
          case 4://DONE
            if(this.status == 200||this.status == 304){
                console.log(this.responseText);
                }
            console.log("DONE")
            break;
        }
    }

    xhr.ontimeout = function(e) { console.log('ontimeout') }
    xhr.onerror = function(e) { console.log('onerror') }

    /**
     * 3:打开请求
     */
    xhr.open('Get', URL, true);//创建一个Get请求,采用异步


    /**
     * 4:配置参数
     */
    xhr.timeout = 3000 //设置xhr请求的超时时间
    xhr.responseType = "text" //设置响应返回的数据格式
    xhr.setRequestHeader("X_TEST","time.geekbang")

    /**
     * 5:发送请求
     */
    xhr.send();
}
```

- 第一步：创建XMLHttpRequest对象
- 第二步：为xhr对象注册回调函数

- - 因为网络请求比较耗时，所以要注册回调函数，这样后台任务执行完成之后就会通过调用回调函数来告诉其执行结果。
  - XMLHttpRequest 的回调函数主要有下面几种：

- - - ontimeout，用来监控超时请求，如果后台请求超时了，该函数会被调用；
    - onerror，用来监控出错信息，如果后台请求出错了，该函数会被调用；

- - - onreadystatechange，用来监控后台请求过程中的状态，比如可以监控到 HTTP 头加载完成的消息、HTTP 响应体消息以及数据加载完成的消息等。

- 第三步：配置基础的请求信息

- - 通过open接口配置一些基础的请求信息，包括请求的地址、请求方法和请求方式。然后通过xhr内部属性类配一些其他可选的请求信息。

- 第四步：发起请求

- - 通过xhr.send发起网络请求。
  - 如果网络请求出错了，就会执行 xhr.onerror；

- - 如果超时了，就会执行 xhr.ontimeout；
  - 如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。



## XMLHttpRequest使用过程中的问题

- 跨域问题
- https混合内容的问题

- - 在https的网站中请求http的接口，会报错

## 什么是V8？

是一个由Google开发的开源JavaScript引擎，目前用在Chrome浏览器和Node.js 中，其核心功能是执行易于人类理解的JavaScript代码。



## V8的核心流程

`编译`和`执行`。首先需要将JavaScript代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637212995261-b4d8b87a-70cf-4be9-a938-c1183e553603.png)



## 处理器如何处理高级语言？

第一种方法是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213464861-d0181c5e-2669-4a99-9692-4fbe37a84a3a.png)

第二种是编译执行。采取这种方式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序时直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213576784-ca3e5768-ad2e-41d3-bc4b-e4b30de479d2.png)



执行JavaScript语言有好几种虚拟机（引擎），v8只是其中的一种。



## V8是怎么执行JavaScript代码的？

V8在执行JavaScript代码时采用的是混合编译执行和解释执行这两种手段，称为JIT（Just In Time）技术。

解释执行的启动速度快执行速度慢，而编辑执行是启动速度慢执行速度快，所以JIT结合这两种方法的有点。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213779552-5766ec86-79bf-4fc1-86fb-4545e1f00f49.png)



首先，在V8启动执行JavaScript之前，需要准备JavaScript执行时所需要的一些基础环境，包括“堆空间”、“栈空间”、“全局执行上下文”、“全局作用域”、“消息循环系统”、“内置函数”等，这些内容都是在执行JavaScript过程中需要用到的。

比如：

- 全局执行上下文包含了执行过程中的全局信息，如内置函数、全局变量等信息；
- 全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；

- 还需要准备堆栈管理需要的堆栈结构。
- 初始化消息循环系统，不断接收信息并决策如何处理消息。



1. V8会接收到要执行的JavaScript源代码字符串，此时V8不能直接解读这些源码字符串，需要结构化这些字符串。

2. 源码结构化之后，生成抽象语法树（AST），生成AST的同时，还会生成相关的作用域。

3. 有了AST和作用域之后，接下来开始生成字节码，字节码是介于AST和机器代码的中间代码。

4. 解析器按照顺序解释执行字节码，并输出执行结构。

5. 监控解释器会把重复多次执行的代码标记为热点代码。

6. 当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作。在之后再执行这段代码时，V8会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。

7. 当对象结构被动态修改时，优化后的代码就会被优化编译器反优化，恢复到解释器中解释执行。



# JavaScript函数的特点

## 函数的本质

函数是一种特殊的对象，它和对象一样可以拥有属性和值，但是函数和普通对象不同的是函数可以被调用。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637324373389-7256d7d2-83c9-4043-bbec-ad714f4a5ecb.png)

在V8中，会为函数增加两个隐藏属性。`name`和`code`。

`name`属性的值就是函数名称，默认值是`anonymous`，表示该函数对象没有被设置名称。

`code`属性，表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8便会从函数对象中取出`code`属性值，也就是函数代码，然后再解释执行这段函数代码。



如果某个编程语言的函数可以和它的数据类型做一样的事情，我们就把这个语言中的函数称为`一等公民`。

> 通常，如果一个值它可以作为一个参数传递，可以被函数返回，可以被存储在变量中，那它就被称为一等公民。



# V8采用了哪些策略提升了对象属性的访问速度

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637416143371-2e604d44-9c1b-4a13-981d-b402dc6b8332.png)

## 常规属性（properties）和排序属性（elements）

```jsx
var obj = {b: 10, a: 20};
obj[10] = 30;
obj[1] = 40;

for (key in obj) {
	console.log(key, obj[key]);
}
// 1, 40
// 10, 30
// b, 10
// a, 20
```

ECMAScript规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。

对象中的数字属性称为排序属性，字符串属性称为常规属性。

在V8内部，为了有效地提高存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。

当执行索引操作时，V8会先从排序属性中按照顺序读取所有的元素，然后再从常规属性中读取所有的元素，这样就完成一次索引操作。



## 快属性和慢属性

对属性进行区分简化了程序的复杂度，但是却在查找元素时，多了一步操作。基于此原因，V8采取了一个权衡的策略以加快查找属性的效率，将部分常规属性直接存储到对象本身，这样的属性称为`对象内属性（in-object properties）`

不过对象内属性的数量是固定的，默认是**10个**，如果添加的属性超过了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自有地扩容。

将保存在线性数据结构中的属性称为`快属性`，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。



如果一个对象的属性过多时，V8就会采取另外一种存储策略`慢属性`，但慢属性的对象内部会有独立的非线性结构作为属性存储容器，所有的属性元信息不再是线性存储的，而是直接保存到属性字典中。

```javascript
function Foo(len) {
  new Array(len).fill(1).forEach((item, index) => {
    this[index] = 'elements' + index;
  });
  new Array(len).fill(1).forEach((item, index) => {
    this[`index_${index}`] = 'properties' + index;
  });
}
const foo = new Foo(10);
const foo1 = new Foo(20);
const foo2 = new Foo(100);
```

**当只创建了十个常规属性时，10个常规属性作为对象内属性，存放在foo函数内部，10个排序属性存放在elements中。**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417036090-a63269dd-7737-4d7a-a318-77b34552c184.png)

**当创建20常规属性时，10个属性直接存放在foo1的对象内；10个常规属性以线性数据结构存放在properties属性内；20个排序属性存放在elements属性内；**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417147206-7993ce70-b77e-4cb6-9234-e196ee90918b.png)

**当创建100个常规属性时，10个属性存放在foo2对象内部；90个常规属性以非线性字段的数据结构存放在properties属性中；100个排序属性存放在elements属性里面；**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417262769-b4f08eca-b9b7-4452-bdd4-0fc38ad6d3cd.png)



```javascript
function Foo() {};
const obj = new Foo()
obj['name'] = 'wang';
obj['age'] = 20;
obj[1] = 'yu';
obj[2] = 'yu';
obj[1000] = 'yu';
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417915546-06538650-2b9d-4cc5-9bfa-2d559ce0a835.png)

element中的数据存放如果是稀疏数组的情况下（下标从2跨越到1000），为了节省空间，稀疏数组会转换为哈希存储的方式，而不再是用一个完整的数组描述这块空间的存储。



**为什么有序的线性结构查找起来要比无序的非线性结构的查找耗时要短？**

> 因为线性结构的查找是线性结构长度次的简单位运算，而非线性结构要先经过哈希算法计算。这是一个复杂计算。



# 函数表达式

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637502566948-16fb9167-1100-4035-9736-4b44d53bcacf.png)



V8在处理函数声明的时候会存在变量提升，在编译阶段，foo函数对象就被V8存放在内存中的堆空间（作用域）中，所以在执行阶段，V8就能获取到所有定义的函数。

而如果是一个普通变量，变量提升后会先赋值为undefined。



表达式就是表示值的句子，语句是操作值的式子。

比如

> x = 5

就是一个表示式，因为执行代码，会返回一个值。

而

> var x

就是一个语句，执行该语句时，V8并不会返回任何值给你。

所以函数声明也是一个语句。

```javascript
var x = 5;

// 这段代码在V8眼中是两个阶段
var x = undefined;
x = 5;
```

其中`var x`是在编译阶段完成的，也就是变量提升阶段，而`x = 5`是表达式，所有的表达式都是在执行阶段完成的。函数也是一个对象，所有在编译阶段，V8就会将整个函数对象提升到作用域中，并不是给该函数名称赋值为undefined。

```javascript
foo()
var foo = function () {
	console.log(1);
}

// 这段代码在V8眼中是两个阶段
var foo = undefined;
foo = function () {
	console.log(1);
}
```

函数表达式是表达式，所以是在执行阶段才赋值的。



**立即调用的函数表达式（IIFE）**

JavaScript中有一个圆括号运算符，圆括号里可以放一个表达式。

```javascript
(function () {
	console.log(1);
})
```

如果在小括号中定义一个函数，那么V8就会把这个函数看做是函数表达式，执行时它会返回一个函数对象，可以直接调用。

因为函数立即表达式是立即执行的，所有将一个函数立即表达式赋值给一个变量时，不是存储函数本身，而是存储函数执行后的结果。

```javascript
var a = (function () {
	return 1;
});
console.log(a) // 1
```



# 原型链继承

每一个JavaScript对象都有一个原型属性（`__proto__`），该属性指向了该对象的原型对象，查找属性的时候，JavaScript虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637541243537-cb264bc0-3805-4d09-b6ea-29c420c1c22b.png)

```javascript
function DogFactory(type, color) {
	this.type = type;
  this.color = color;
}
var dog = new DogFactory('Dog', 'Black');

console.log(dog.__proto__ === DogFactory.prototype) // true
console.log(DogFactory.__proto__ === Function.prototype) // true
console.log(DogFactory.prototype.__proto__ === Object.prototype) // true
```

DogFactory 是 Function构造函数的一个实例，所有DogFactory的远行属性__proto__ 指向Function的prototype，而dog是DogFactory的实例，所以`dog.__proto__ === DogFactory.prototype`。



V8执行这段代码时

```javascript
var dpg = {};
dog.__proto__ = DogFactory.prototype;
DogFactory.call(dof, 'Dog', 'Black');
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637541630395-cd141541-c396-4cf0-9946-094f43f8de59.png)

- 首先，创建一个空白对象dog；
- 将DogFactory的prototype属性设置为dog的原型对象；

- 最后，再使用dog来调用DogFactory，这时候DogFactory函数中的this就指向对象dog，然后在DogFactory函数中，利用this对对象dog执行属性填充操作，最终就创建了对象dog；



每个函数对象都有一个公开的prototype属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建的对象的原型对象就指向了该函数的prototype属性。正常调用函数时，prototype属性不起作用。



# 作用域链

> 作用域链就是将一个个作用域串起来，实现变量查找的路径。讨论作用域链，实际就是在讨论按照什么路径查找变量的问题。

作用域就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。

全局作用域是在V8启动过程中就创建了，且一直保存在内存中不会被销毁的，直至V8退出。而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了。

```js
var type = 'a1';
var name = 'a';
function foo() {
  	var name = 'c';
  	console.log(name); // c
    console.log(type); // a1
}
function bar() {
    var type = 'b1';
  	var name = 'b';
    foo();
}
bar();
```

 

+ 这段代码，当V8启动时，会创建全局作用域，全局作用域包含了this、window等变量，还有一些全局的web API接口。

+ V8启动后，执行代码。

+ 首先预编译代码，在编译过程中会将顶层（全局）定义的变量和声明的函数都添加到全局作用域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559652650-ed11f458-bc99-499f-998b-c7527f0c79c4.png)

+ 全局作用域创建完之后，进入执行状态。

+ 当V8执行bar函数的时候，同样需要经过编译和执行两个阶段。在编译阶段，V8会为bar函数创建函数作用域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559748458-0d77eba0-604a-4ca6-a5bd-12e2f6a6c5d3.png)

+ 然后在bar中调用foo函数，又会进入foo函数的编译和执行阶段。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559785527-53d9e451-becb-4927-83f0-c1d495560163.png)



JavaScript是基于词法作用域的，词法作用域是指，查找作用域的顺序是按照函数定义时的位置来决定的。bar和foo函数的外部代码都是全局代码，所以无论在bar函数中查找变量还是在foo函数中查找变量，其查找顺序都是`当前作用域 -> 全局作用域`这个路径。



词法作用域因为是根据函数在代码中的位置来确定的，作用域在声明函数的时候已经确定好了，所以词法作用域也称为`静态作用域`。

相对的 动态作用域只关心函数是在何处调用的，不关心函数是在何处声明的。

作用域链式基于调用栈的，而不是基于函数定义的位置的。



# 类型转换

1 + '2' 为什么等于 '12' ？

类型系统：用于定义如何将编程语言中的述职和表达式归类为许多不同的类型，如何操作这些类型，这些类型如何相互作用。

## V8是如何执行加法操作的？

V8会提供一个ToPrimitive方法，其作用是将a和b转换为原生数据类型

- 先检测该对象中是否存在valueOf方法，如果有并返回了原始类型，那么久使用该值进行强制类型转换；
- 如果valueOf没有返回原始类型，那么就使用toString方法的返回值；

- 如果valueOf和toString两个方法都不返回基本类型值，便会触发一个TypeError的错误；

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637584566447-41e337df-6534-4b98-9cba-4f0b18c0102e.png)



当执行1 + '2'时，因为这是两个原始值相加，其中一项为字符串，那么V8默认将另一个值也转为字符串。相当于

```jsx
Number(1).toString() + '2';
```



# JavaScript运行时环境

## 宿主环境

V8的宿主环境可以是浏览器、NodeJS或其他开发环境。提供了V8执行JavaScript时所需要的基本功能部件。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637679569272-465af41a-d748-4e17-adb4-757bfc67e48e.png)



## 堆栈空间

栈空间主要是用来管理JavaScript函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放到栈上，比如原生类型、应用到的对象的地址、函数的执行状态、this值等都会存在于栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。

栈空间的最大的特点是空间连续，所有在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8对栈空间的大小做了限制，如果函数调用层过深，那么V8就可能抛出栈溢出的错误。

Maximum call stack size exceeded



如果有一些占用内存比较大的数据，或者不需要存储在连续空间中的数据，可以使用堆空间。

堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，函数、数组、浏览器内置对象，都存在堆空间中。



## 全局执行上下文和全局作用域

当V8开始执行一段可执行代码时，会生成一个执行上下文。V8用执行上下文来维护执行当前代码所需要的变量声明、this指向等。

执行上下文中主要包含了三部分，变量环境、词法环境、和this关键字。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637680353273-f37636b4-d188-4b20-be3d-5f6815ba9e37.png)

全局执行上下文在V8的生命周期内是不会被销毁的，它会一直保存在堆中，这样当下次再需要使用函数或全局变量时，就不需要重新创建了。



当V8调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函数执行上下文就形成了一个栈接口。



# 函数调用与内存布局



```js
// 栈溢出
function foo() {
	foo();
}
foo();

// 正常执行
function foo() {
	setTimeout(foo, 0);
}
foo();

// 不会栈溢出，但会导致整个页面卡住
function foo() {
	return Promise.resolve().then(foo);
}
foo();
```

这三段代码的底层执行逻辑分别是：

- 第一段代码是在同一个任务中重复调用嵌套的foo函数；
- 第二段代码是使用setTimeout让foo函数在不同的任务中执行；

- 第三段代码是在同一个任务中执行foo函数，但是却不是嵌套执行。

三种不同的执行方式，V8执行时的内存布局是不一样的。



为什么用栈结构来管理函数调用？

第一个特点是函数可以被调用，你可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制器将从富含鼠转移到子函数，子函数执行结束之后，又会将代码执行控制器返还给父函数。

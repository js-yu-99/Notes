## 什么是V8？

是一个由Google开发的开源JavaScript引擎，目前用在Chrome浏览器和Node.js 中，其核心功能是执行易于人类理解的JavaScript代码。



## V8的核心流程

`编译`和`执行`。首先需要将JavaScript代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637212995261-b4d8b87a-70cf-4be9-a938-c1183e553603.png)



## 处理器如何处理高级语言？

第一种方法是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213464861-d0181c5e-2669-4a99-9692-4fbe37a84a3a.png)

第二种是编译执行。采取这种方式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序时直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213576784-ca3e5768-ad2e-41d3-bc4b-e4b30de479d2.png)



执行JavaScript语言有好几种虚拟机（引擎），v8只是其中的一种。



## V8是怎么执行JavaScript代码的？

V8在执行JavaScript代码时采用的是混合编译执行和解释执行这两种手段，称为JIT（Just In Time）技术。

解释执行的启动速度快执行速度慢，而编辑执行是启动速度慢执行速度快，所以JIT结合这两种方法的有点。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213779552-5766ec86-79bf-4fc1-86fb-4545e1f00f49.png)



首先，在V8启动执行JavaScript之前，需要准备JavaScript执行时所需要的一些基础环境，包括“堆空间”、“栈空间”、“全局执行上下文”、“全局作用域”、“消息循环系统”、“内置函数”等，这些内容都是在执行JavaScript过程中需要用到的。

比如：

- 全局执行上下文包含了执行过程中的全局信息，如内置函数、全局变量等信息；
- 全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；

- 还需要准备堆栈管理需要的堆栈结构。
- 初始化消息循环系统，不断接收信息并决策如何处理消息。



1. V8会接收到要执行的JavaScript源代码字符串，此时V8不能直接解读这些源码字符串，需要结构化这些字符串。

2. 源码结构化之后，生成抽象语法树（AST），生成AST的同时，还会生成相关的作用域。

3. 有了AST和作用域之后，接下来开始生成字节码，字节码是介于AST和机器代码的中间代码。

4. 解析器按照顺序解释执行字节码，并输出执行结构。

5. 监控解释器会把重复多次执行的代码标记为热点代码。

6. 当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作。在之后再执行这段代码时，V8会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。

7. 当对象结构被动态修改时，优化后的代码就会被优化编译器反优化，恢复到解释器中解释执行。



# JavaScript函数的特点

## 函数的本质

函数是一种特殊的对象，它和对象一样可以拥有属性和值，但是函数和普通对象不同的是函数可以被调用。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637324373389-7256d7d2-83c9-4043-bbec-ad714f4a5ecb.png)

在V8中，会为函数增加两个隐藏属性。`name`和`code`。

`name`属性的值就是函数名称，默认值是`anonymous`，表示该函数对象没有被设置名称。

`code`属性，表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8便会从函数对象中取出`code`属性值，也就是函数代码，然后再解释执行这段函数代码。



如果某个编程语言的函数可以和它的数据类型做一样的事情，我们就把这个语言中的函数称为`一等公民`。

> 通常，如果一个值它可以作为一个参数传递，可以被函数返回，可以被存储在变量中，那它就被称为一等公民。



# V8采用了哪些策略提升了对象属性的访问速度

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637416143371-2e604d44-9c1b-4a13-981d-b402dc6b8332.png)

## 常规属性（properties）和排序属性（elements）

```jsx
var obj = {b: 10, a: 20};
obj[10] = 30;
obj[1] = 40;

for (key in obj) {
	console.log(key, obj[key]);
}
// 1, 40
// 10, 30
// b, 10
// a, 20
```

ECMAScript规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。

对象中的数字属性称为排序属性，字符串属性称为常规属性。

在V8内部，为了有效地提高存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。

当执行索引操作时，V8会先从排序属性中按照顺序读取所有的元素，然后再从常规属性中读取所有的元素，这样就完成一次索引操作。



## 快属性和慢属性

对属性进行区分简化了程序的复杂度，但是却在查找元素时，多了一步操作。基于此原因，V8采取了一个权衡的策略以加快查找属性的效率，将部分常规属性直接存储到对象本身，这样的属性称为`对象内属性（in-object properties）`

不过对象内属性的数量是固定的，默认是**10个**，如果添加的属性超过了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自有地扩容。

将保存在线性数据结构中的属性称为`快属性`，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。



如果一个对象的属性过多时，V8就会采取另外一种存储策略`慢属性`，但慢属性的对象内部会有独立的非线性结构作为属性存储容器，所有的属性元信息不再是线性存储的，而是直接保存到属性字典中。

```javascript
function Foo(len) {
  new Array(len).fill(1).forEach((item, index) => {
    this[index] = 'elements' + index;
  });
  new Array(len).fill(1).forEach((item, index) => {
    this[`index_${index}`] = 'properties' + index;
  });
}
const foo = new Foo(10);
const foo1 = new Foo(20);
const foo2 = new Foo(100);
```

**当只创建了十个常规属性时，10个常规属性作为对象内属性，存放在foo函数内部，10个排序属性存放在elements中。**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417036090-a63269dd-7737-4d7a-a318-77b34552c184.png)

**当创建20常规属性时，10个属性直接存放在foo1的对象内；10个常规属性以线性数据结构存放在properties属性内；20个排序属性存放在elements属性内；**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417147206-7993ce70-b77e-4cb6-9234-e196ee90918b.png)

**当创建100个常规属性时，10个属性存放在foo2对象内部；90个常规属性以非线性字段的数据结构存放在properties属性中；100个排序属性存放在elements属性里面；**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417262769-b4f08eca-b9b7-4452-bdd4-0fc38ad6d3cd.png)



```javascript
function Foo() {};
const obj = new Foo()
obj['name'] = 'wang';
obj['age'] = 20;
obj[1] = 'yu';
obj[2] = 'yu';
obj[1000] = 'yu';
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417915546-06538650-2b9d-4cc5-9bfa-2d559ce0a835.png)

element中的数据存放如果是稀疏数组的情况下（下标从2跨越到1000），为了节省空间，稀疏数组会转换为哈希存储的方式，而不再是用一个完整的数组描述这块空间的存储。



**为什么有序的线性结构查找起来要比无序的非线性结构的查找耗时要短？**

> 因为线性结构的查找是线性结构长度次的简单位运算，而非线性结构要先经过哈希算法计算。这是一个复杂计算。



# 函数表达式

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637502566948-16fb9167-1100-4035-9736-4b44d53bcacf.png)



V8在处理函数声明的时候会存在变量提升，在编译阶段，foo函数对象就被V8存放在内存中的堆空间（作用域）中，所以在执行阶段，V8就能获取到所有定义的函数。

而如果是一个普通变量，变量提升后会先赋值为undefined。



表达式就是表示值的句子，语句是操作值的式子。

比如

> x = 5

就是一个表示式，因为执行代码，会返回一个值。

而

> var x

就是一个语句，执行该语句时，V8并不会返回任何值给你。

所以函数声明也是一个语句。

```javascript
var x = 5;

// 这段代码在V8眼中是两个阶段
var x = undefined;
x = 5;
```

其中`var x`是在编译阶段完成的，也就是变量提升阶段，而`x = 5`是表达式，所有的表达式都是在执行阶段完成的。函数也是一个对象，所有在编译阶段，V8就会将整个函数对象提升到作用域中，并不是给该函数名称赋值为undefined。

```javascript
foo()
var foo = function () {
	console.log(1);
}

// 这段代码在V8眼中是两个阶段
var foo = undefined;
foo = function () {
	console.log(1);
}
```

函数表达式是表达式，所以是在执行阶段才赋值的。



**立即调用的函数表达式（IIFE）**

JavaScript中有一个圆括号运算符，圆括号里可以放一个表达式。

```javascript
(function () {
	console.log(1);
})
```

如果在小括号中定义一个函数，那么V8就会把这个函数看做是函数表达式，执行时它会返回一个函数对象，可以直接调用。

因为函数立即表达式是立即执行的，所有将一个函数立即表达式赋值给一个变量时，不是存储函数本身，而是存储函数执行后的结果。

```javascript
var a = (function () {
	return 1;
});
console.log(a) // 1
```



# 原型链继承

每一个JavaScript对象都有一个原型属性（`__proto__`），该属性指向了该对象的原型对象，查找属性的时候，JavaScript虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637541243537-cb264bc0-3805-4d09-b6ea-29c420c1c22b.png)

```javascript
function DogFactory(type, color) {
	this.type = type;
  this.color = color;
}
var dog = new DogFactory('Dog', 'Black');

console.log(dog.__proto__ === DogFactory.prototype) // true
console.log(DogFactory.__proto__ === Function.prototype) // true
console.log(DogFactory.prototype.__proto__ === Object.prototype) // true
```

DogFactory 是 Function构造函数的一个实例，所有DogFactory的远行属性__proto__ 指向Function的prototype，而dog是DogFactory的实例，所以`dog.__proto__ === DogFactory.prototype`。



V8执行这段代码时

```javascript
var dpg = {};
dog.__proto__ = DogFactory.prototype;
DogFactory.call(dof, 'Dog', 'Black');
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637541630395-cd141541-c396-4cf0-9946-094f43f8de59.png)

- 首先，创建一个空白对象dog；
- 将DogFactory的prototype属性设置为dog的原型对象；

- 最后，再使用dog来调用DogFactory，这时候DogFactory函数中的this就指向对象dog，然后在DogFactory函数中，利用this对对象dog执行属性填充操作，最终就创建了对象dog；



每个函数对象都有一个公开的prototype属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建的对象的原型对象就指向了该函数的prototype属性。正常调用函数时，prototype属性不起作用。



# 作用域链

> 作用域链就是将一个个作用域串起来，实现变量查找的路径。讨论作用域链，实际就是在讨论按照什么路径查找变量的问题。

作用域就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。

全局作用域是在V8启动过程中就创建了，且一直保存在内存中不会被销毁的，直至V8退出。而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了。

```js
var type = 'a1';
var name = 'a';
function foo() {
  	var name = 'c';
  	console.log(name); // c
    console.log(type); // a1
}
function bar() {
    var type = 'b1';
  	var name = 'b';
    foo();
}
bar();
```

 

+ 这段代码，当V8启动时，会创建全局作用域，全局作用域包含了this、window等变量，还有一些全局的web API接口。

+ V8启动后，执行代码。

+ 首先预编译代码，在编译过程中会将顶层（全局）定义的变量和声明的函数都添加到全局作用域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559652650-ed11f458-bc99-499f-998b-c7527f0c79c4.png)

+ 全局作用域创建完之后，进入执行状态。

+ 当V8执行bar函数的时候，同样需要经过编译和执行两个阶段。在编译阶段，V8会为bar函数创建函数作用域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559748458-0d77eba0-604a-4ca6-a5bd-12e2f6a6c5d3.png)

+ 然后在bar中调用foo函数，又会进入foo函数的编译和执行阶段。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559785527-53d9e451-becb-4927-83f0-c1d495560163.png)



JavaScript是基于词法作用域的，词法作用域是指，查找作用域的顺序是按照函数定义时的位置来决定的。bar和foo函数的外部代码都是全局代码，所以无论在bar函数中查找变量还是在foo函数中查找变量，其查找顺序都是`当前作用域 -> 全局作用域`这个路径。



词法作用域因为是根据函数在代码中的位置来确定的，作用域在声明函数的时候已经确定好了，所以词法作用域也称为`静态作用域`。

相对的 动态作用域只关心函数是在何处调用的，不关心函数是在何处声明的。

作用域链式基于调用栈的，而不是基于函数定义的位置的。



# 类型转换

1 + '2' 为什么等于 '12' ？

类型系统：用于定义如何将编程语言中的述职和表达式归类为许多不同的类型，如何操作这些类型，这些类型如何相互作用。

## V8是如何执行加法操作的？

V8会提供一个ToPrimitive方法，其作用是将a和b转换为原生数据类型

- 先检测该对象中是否存在valueOf方法，如果有并返回了原始类型，那么久使用该值进行强制类型转换；
- 如果valueOf没有返回原始类型，那么就使用toString方法的返回值；

- 如果valueOf和toString两个方法都不返回基本类型值，便会触发一个TypeError的错误；

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637584566447-41e337df-6534-4b98-9cba-4f0b18c0102e.png)



当执行1 + '2'时，因为这是两个原始值相加，其中一项为字符串，那么V8默认将另一个值也转为字符串。相当于

```jsx
Number(1).toString() + '2';
```



# JavaScript运行时环境

## 宿主环境

V8的宿主环境可以是浏览器、NodeJS或其他开发环境。提供了V8执行JavaScript时所需要的基本功能部件。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637679569272-465af41a-d748-4e17-adb4-757bfc67e48e.png)



## 堆栈空间

栈空间主要是用来管理JavaScript函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放到栈上，比如原生类型、应用到的对象的地址、函数的执行状态、this值等都会存在于栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。

栈空间的最大的特点是空间连续，所有在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8对栈空间的大小做了限制，如果函数调用层过深，那么V8就可能抛出栈溢出的错误。

Maximum call stack size exceeded



如果有一些占用内存比较大的数据，或者不需要存储在连续空间中的数据，可以使用堆空间。

堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，函数、数组、浏览器内置对象，都存在堆空间中。



## 全局执行上下文和全局作用域

当V8开始执行一段可执行代码时，会生成一个执行上下文。V8用执行上下文来维护执行当前代码所需要的变量声明、this指向等。

执行上下文中主要包含了三部分，变量环境、词法环境、和this关键字。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637680353273-f37636b4-d188-4b20-be3d-5f6815ba9e37.png)

全局执行上下文在V8的生命周期内是不会被销毁的，它会一直保存在堆中，这样当下次再需要使用函数或全局变量时，就不需要重新创建了。



当V8调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函数执行上下文就形成了一个栈接口。



# 函数调用与内存布局



```js
// 栈溢出
function foo() {
	foo();
}
foo();

// 正常执行
function foo() {
	setTimeout(foo, 0);
}
foo();

// 不会栈溢出，但会导致整个页面卡住
function foo() {
	return Promise.resolve().then(foo);
}
foo();
```

这三段代码的底层执行逻辑分别是：

- 第一段代码是在同一个任务中重复调用嵌套的foo函数；
- 第二段代码是使用setTimeout让foo函数在不同的任务中执行；

- 第三段代码是在同一个任务中执行foo函数，但是却不是嵌套执行。

三种不同的执行方式，V8执行时的内存布局是不一样的。

## 为什么使用栈结构来管理函数调用？

### 函数的特点：

+ 第一个特点是函数可以被调用，你可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制器将从富含鼠转移到子函数，子函数执行结束之后，又会将代码执行控制器返还给父函数。

+ 第二个特点是函数具有作用域机制，所谓作用域机制，是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量我们也称为临时变量，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁。

**函数调用者的生命周期总是长于被调用者（后进），并且被调用者的生命周期总是先于调用者声明周期结束（先出）**

函数作用域在函数执行完成之后，会将其内部数据销毁掉。站在函数资源分配和回收角度来看，**被调用函数的资源分配总是晚于调用函数（后进），而资源函数的释放总是先于调用函数（先出）**。

函数的生命周期和资源分配和栈一样符合后进先出的策略，所以用栈来管理函数调用。



## 栈如何管理函数调用

当执行函数内子函数的调用结束后，会将栈的状态恢复为当前函数上次执行时的状态，这个过程叫恢复现场。寄存器中会保存一个永远执行当前栈顶的指针，栈顶指针的作用就是告诉你应该往哪个位置添加新元素，这个指针通常存放在esp寄存器中。

**栈帧中保存了该函数的返回地址和局部变量**。在JavaScript中，如果调用一个新函数，那么V8会为该函数创建栈帧，等函数执行结束之后，销毁该栈帧，而栈结构的容量是固定的，所以如果重复嵌套执行一个函数，那么就会导致栈溢出。

递归的时候，因为没有结束条件，就会导致每次都有一个新的执行上下文加入到调用栈中，却不会有出栈的情况，这样就很容易超出栈的最大容量，导致栈溢出报错。



# V8是如何实现闭包的？



在编译JavaScript代码的过程中，V8并不会一次性将所有的JavaScript解析为中间代码。

+ 首先，如果一次解析和编译所有的JavaScript代码，过多的代码会增加编译时间，这会严重影响到首次执行JavaScript代码的熟读，让用户感觉到卡顿。

+ 其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有JavaScript代码，那么这些中间代码和机器代码将会一直占用内存。

现在的所有JavaScript虚拟机都实现了惰性解析。

> 解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成AST和字节码，而仅仅生成顶层代码的AST和字节码。



```javascript
function foo(a, b) {
	var d = 100;
  var f = 10;
  return d + f + a + b;
}
var a = 1;
var c = 4;
foo(1, 5);
```

当这段代码交给V8处理时，V8会至上而下解析这段代码，在解析时，V8只是把foo函数解析为函数对象，但是并没有解析和编译函数内部的代码，所有不会为foo函数的内部代码生成抽象语法树。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637933273160-032cced5-9843-4dc7-be55-a83333553bf7.png)

而 a、c等其他顶层代码会生成抽象语法树。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637933448857-cb474f8d-14f8-44a4-afff-1fc46ca9dcb0.png)

## JavaScript闭包的三个特性

- JavaScript语言允许在函数内部定义新的函数
- 可以在内部函数中访问父函数中定义的变量

- 因为函数是一等公民，所有函数可以作为返回值



## 闭包给惰性解析带来的问题

```javascript
function foo() {
	var d = 20;
  return function inner(a, b) {
  	const c = a + b = d;
    return c;
  }
}
const f = foo();
```

当调用foo函数时，foo函数会将它的内部函数inner返回给全局变量f；

然后foo函数执行结束，执行上下文被V8销毁了；

虽然foo函数的执行上下文被销毁了，但是依然存活的inner函数引用了foo函数作用域中的变量d；



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638085255433-82e63733-4746-4109-b43e-9e756fd28ff8.png)

执行全局代码时，V8会将全局执行上下文压入到调用栈中，然后进入执行foo函数的调用过程，这时候V8会为foo函数创建执行上下文，执行上下文中包括了变量d，然后将foo函数的执行上下文压入栈中，foo函数执行结束之后，foo函数执行上下文从栈中弹出，这时候foo执行上下文中的变量d也随之销毁。

但是由于inner函数被保存到全局变量中，所以inner函数依然存在，最关键的地方在于inner函数使用了foo函数中的变量d，按照正常执行流程，变量d在foo函数执行结束之后就被销毁了。但是虽然foo函数的执行上下文被销毁了，但是inner函数引用的foo函数中的变量却不能被销毁，那么这个时候V8就要做特殊处理了，需要保证d变量不随着foo函数的执行结束而销毁。



这个时候需要V8的预解析器来处理这种情况。当解析顶层代码时，遇到一个函数，那么预解析器不会直接跳过该函数，而是对该函数做一次快速的预解析，其目的为：

- 判断当前函数是不是存在一些语法上的错误。
- 检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量赋值到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。



# 二进制机器码究竟是如何被CPU执行的？

V8在执行代码时需要先将JavaScript编译成字节码，然后再解释执行字节码，或者将需要优化的字节码编译成二进制，并直接执行二进制代码。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638088681668-ce836559-b15c-428f-ad49-2d3b55b4270e.png)

计算机硬件结构

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638088745901-758b286d-cc6c-46d0-855f-a18e33be914e.png)



首先，在程序执行之前，我们的程序要被装进内存。而CPU可以通过指定内存地址，从内存中读取数据，或者往内存中写入数据，有了内存地址，CPU和内存就可以有序的交互。

内存中的每个存储空间都有其对应的独一无二的地址。在内存中，每个存放字节的空间都有其唯一的地址，而且地址是按照顺序排放的。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638088852924-5e542597-561e-4a22-9a6a-c35f60a35564.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638088927606-ef492001-143c-4f33-8df9-b44ce909d1a3.png)



一旦二进制代码被装载进内存，CPU就可以从内存中取出一条指令，然后分析该指令，最后执行该指令。

把取出指令、分析指令、执行指令这三个过程称为一个CPU始终周期。CPU是一直在执行指令到，重复这个时钟周期，直到所有的指令执行完成。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638089052735-1eb142ed-a8ab-470c-991e-db4ebc7b176c.png)

CPU中有一个PC寄存起，保存了将要执行的指令地址。在下一个时钟周期开始之前，CPU会根据PC寄存器中的地址，从内存中取出指令。

PC寄存器中的指令取出来之后，将下一条指令的地址更新到PC寄存器中，分析取出的指令，识别、获取等操作后，执行指令。



通用寄存器是CPU中用来存放数据的设备，不同处理器中寄存器的个数也不一样，之所以要通用寄存器，是因为CPU访问内存的速度很慢，所有CPU需要在内部添加一些存储设备。

通用寄存器容量小，读写速度快，内存容量大，读写速度慢。

通用寄存器通常用来存放数据或者内存中某块数据的地址。



# 如何在内存中快速查找对象属性

## 为什么静态语言的效率更高？

JavaScript在运行时，对象的属性是可以被修改的，所以当V8使用了一个对象时，它不知道该对象中是否存在某个属性，也不知道属性相对于对象的偏移量是多少。当JavaScript中要查询对象属性时，V8会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。

静态语言C++在声明一个对象之前需要定义该对象的结构，我们也可以称为形状，我们可以只用这个形状来定义具体的对象。C++代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中，形状是无法被改变的。当在C++中使用对象时，直接去内存地址中取出该内容即可，没有任何中间的查找环节。

```cpp
struct Point {
	int x;
    int y;
}
Point start;
start.x = 100;
start.y = 200;
```

V8将这种静态语言的特性引入到引擎中。

V8在运行JavaScript的过程中，会假设JavaScript中的对象是静态的，V8对每个对象做两点假设：

- 对象创建好了之后就不会添加新的属性；
- 对象创建好了之后也不会删除属性；

实现上，V8会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括：

- 对象中所包含的所有的属性；
- 每种类型相对于对象的偏移量；

有了隐藏类之后，当V8访问某个对象中的某个属性是，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8就可以直接去内存中取出对应的属性值。

```jsx
let point = {x: 100, y: 200};
```

当V8执行到这里是，会先为point对象创建一个隐藏类（map），每个对象都有一个map的属性，其值指向内存中的隐藏类。**point对象的第一个属性的指针指向map地址**。

隐藏类描述了对象的属性布局，包括了属性名称和每个属性所对应的偏移量，比如point对象的隐藏类就包括了x和y属性，x的偏移量是4，y的偏移量是8。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638187450383-c9b23950-4d66-4a6e-83d0-977f5f03bc89.png)



map不是point对象本身。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638187474123-1f151309-6188-46f5-a4c7-baf4feb93553.png)

多个相同形状的对象可以共用一个隐藏类。好处是：

- 减少隐藏类的创建次数，也间接加速了代码的执行速度；
- 减少了隐藏类的存储空间；

如何判断对象形状相同？相同的属性名称和属性个数；

```cpp
const point = {x: 100, y: 200};
const point2 = {x: 1, y: 2};
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638187631207-9971451b-aeb7-4460-88f5-37519c54be2a.png)

如果对象的形状发生了改变，那么V8会重建一个新的隐藏类给该对象。

所以日常开发中需要注意几点：

- 使用字面量初始化时，要保证属性的顺序是一致的；
- 尽量使用字面量一次性初始化完整对象属性；

- 尽量避免使用delete方法




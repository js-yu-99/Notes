## 什么是V8？

是一个由Google开发的开源JavaScript引擎，目前用在Chrome浏览器和Node.js 中，其核心功能是执行易于人类理解的JavaScript代码。



## V8的核心流程

`编译`和`执行`。首先需要将JavaScript代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637212995261-b4d8b87a-70cf-4be9-a938-c1183e553603.png)



## 处理器如何处理高级语言？

第一种方法是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213464861-d0181c5e-2669-4a99-9692-4fbe37a84a3a.png)

第二种是编译执行。采取这种方式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序时直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213576784-ca3e5768-ad2e-41d3-bc4b-e4b30de479d2.png)



执行JavaScript语言有好几种虚拟机（引擎），v8只是其中的一种。



## V8是怎么执行JavaScript代码的？

V8在执行JavaScript代码时采用的是混合编译执行和解释执行这两种手段，称为JIT（Just In Time）技术。

解释执行的启动速度快执行速度慢，而编辑执行是启动速度慢执行速度快，所以JIT结合这两种方法的有点。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213779552-5766ec86-79bf-4fc1-86fb-4545e1f00f49.png)



首先，在V8启动执行JavaScript之前，需要准备JavaScript执行时所需要的一些基础环境，包括“堆空间”、“栈空间”、“全局执行上下文”、“全局作用域”、“消息循环系统”、“内置函数”等，这些内容都是在执行JavaScript过程中需要用到的。

比如：

- 全局执行上下文包含了执行过程中的全局信息，如内置函数、全局变量等信息；
- 全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；

- 还需要准备堆栈管理需要的堆栈结构。
- 初始化消息循环系统，不断接收信息并决策如何处理消息。



1. V8会接收到要执行的JavaScript源代码字符串，此时V8不能直接解读这些源码字符串，需要结构化这些字符串。

2. 源码结构化之后，生成抽象语法树（AST），生成AST的同时，还会生成相关的作用域。

3. 有了AST和作用域之后，接下来开始生成字节码，字节码是介于AST和机器代码的中间代码。

4. 解析器按照顺序解释执行字节码，并输出执行结构。

5. 监控解释器会把重复多次执行的代码标记为热点代码。

6. 当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作。在之后再执行这段代码时，V8会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。

7. 当对象结构被动态修改时，优化后的代码就会被优化编译器反优化，恢复到解释器中解释执行。



# JavaScript函数的特点

## 函数的本质

函数是一种特殊的对象，它和对象一样可以拥有属性和值，但是函数和普通对象不同的是函数可以被调用。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637324373389-7256d7d2-83c9-4043-bbec-ad714f4a5ecb.png)

在V8中，会为函数增加两个隐藏属性。`name`和`code`。

`name`属性的值就是函数名称，默认值是`anonymous`，表示该函数对象没有被设置名称。

`code`属性，表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8便会从函数对象中取出`code`属性值，也就是函数代码，然后再解释执行这段函数代码。



如果某个编程语言的函数可以和它的数据类型做一样的事情，我们就把这个语言中的函数称为`一等公民`。

> 通常，如果一个值它可以作为一个参数传递，可以被函数返回，可以被存储在变量中，那它就被称为一等公民。



# V8采用了哪些策略提升了对象属性的访问速度

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637416143371-2e604d44-9c1b-4a13-981d-b402dc6b8332.png)

## 常规属性（properties）和排序属性（elements）

```jsx
var obj = {b: 10, a: 20};
obj[10] = 30;
obj[1] = 40;

for (key in obj) {
	console.log(key, obj[key]);
}
// 1, 40
// 10, 30
// b, 10
// a, 20
```

ECMAScript规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。

对象中的数字属性称为排序属性，字符串属性称为常规属性。

在V8内部，为了有效地提高存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。

当执行索引操作时，V8会先从排序属性中按照顺序读取所有的元素，然后再从常规属性中读取所有的元素，这样就完成一次索引操作。



## 快属性和慢属性

对属性进行区分简化了程序的复杂度，但是却在查找元素时，多了一步操作。基于此原因，V8采取了一个权衡的策略以加快查找属性的效率，将部分常规属性直接存储到对象本身，这样的属性称为`对象内属性（in-object properties）`

不过对象内属性的数量是固定的，默认是**10个**，如果添加的属性超过了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自有地扩容。

将保存在线性数据结构中的属性称为`快属性`，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。



如果一个对象的属性过多时，V8就会采取另外一种存储策略`慢属性`，但慢属性的对象内部会有独立的非线性结构作为属性存储容器，所有的属性元信息不再是线性存储的，而是直接保存到属性字典中。

```javascript
function Foo(len) {
  new Array(len).fill(1).forEach((item, index) => {
    this[index] = 'elements' + index;
  });
  new Array(len).fill(1).forEach((item, index) => {
    this[`index_${index}`] = 'properties' + index;
  });
}
const foo = new Foo(10);
const foo1 = new Foo(20);
const foo2 = new Foo(100);
```

**当只创建了十个常规属性时，10个常规属性作为对象内属性，存放在foo函数内部，10个排序属性存放在elements中。**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417036090-a63269dd-7737-4d7a-a318-77b34552c184.png)

**当创建20常规属性时，10个属性直接存放在foo1的对象内；10个常规属性以线性数据结构存放在properties属性内；20个排序属性存放在elements属性内；**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417147206-7993ce70-b77e-4cb6-9234-e196ee90918b.png)

**当创建100个常规属性时，10个属性存放在foo2对象内部；90个常规属性以非线性字段的数据结构存放在properties属性中；100个排序属性存放在elements属性里面；**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417262769-b4f08eca-b9b7-4452-bdd4-0fc38ad6d3cd.png)



```javascript
function Foo() {};
const obj = new Foo()
obj['name'] = 'wang';
obj['age'] = 20;
obj[1] = 'yu';
obj[2] = 'yu';
obj[1000] = 'yu';
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417915546-06538650-2b9d-4cc5-9bfa-2d559ce0a835.png)

element中的数据存放如果是稀疏数组的情况下（下标从2跨越到1000），为了节省空间，稀疏数组会转换为哈希存储的方式，而不再是用一个完整的数组描述这块空间的存储。



**为什么有序的线性结构查找起来要比无序的非线性结构的查找耗时要短？**

> 因为线性结构的查找是线性结构长度次的简单位运算，而非线性结构要先经过哈希算法计算。这是一个复杂计算。



# 函数表达式

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637502566948-16fb9167-1100-4035-9736-4b44d53bcacf.png)



V8在处理函数声明的时候会存在变量提升，在编译阶段，foo函数对象就被V8存放在内存中的堆空间（作用域）中，所以在执行阶段，V8就能获取到所有定义的函数。

而如果是一个普通变量，变量提升后会先赋值为undefined。



表达式就是表示值的句子，语句是操作值的式子。

比如

> x = 5

就是一个表示式，因为执行代码，会返回一个值。

而

> var x

就是一个语句，执行该语句时，V8并不会返回任何值给你。

所以函数声明也是一个语句。

```javascript
var x = 5;

// 这段代码在V8眼中是两个阶段
var x = undefined;
x = 5;
```

其中`var x`是在编译阶段完成的，也就是变量提升阶段，而`x = 5`是表达式，所有的表达式都是在执行阶段完成的。函数也是一个对象，所有在编译阶段，V8就会将整个函数对象提升到作用域中，并不是给该函数名称赋值为undefined。

```javascript
foo()
var foo = function () {
	console.log(1);
}

// 这段代码在V8眼中是两个阶段
var foo = undefined;
foo = function () {
	console.log(1);
}
```

函数表达式是表达式，所以是在执行阶段才赋值的。



**立即调用的函数表达式（IIFE）**

JavaScript中有一个圆括号运算符，圆括号里可以放一个表达式。

```javascript
(function () {
	console.log(1);
})
```

如果在小括号中定义一个函数，那么V8就会把这个函数看做是函数表达式，执行时它会返回一个函数对象，可以直接调用。

因为函数立即表达式是立即执行的，所有将一个函数立即表达式赋值给一个变量时，不是存储函数本身，而是存储函数执行后的结果。

```javascript
var a = (function () {
	return 1;
});
console.log(a) // 1
```


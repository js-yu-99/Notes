## 什么是V8？

是一个由Google开发的开源JavaScript引擎，目前用在Chrome浏览器和Node.js 中，其核心功能是执行易于人类理解的JavaScript代码。



## V8的核心流程

`编译`和`执行`。首先需要将JavaScript代码转换为低级中间代码或者机器能够理解的机器代码，然后再执行转换后的代码并输出执行结果。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637212995261-b4d8b87a-70cf-4be9-a938-c1183e553603.png)



## 处理器如何处理高级语言？

第一种方法是解释执行，需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213464861-d0181c5e-2669-4a99-9692-4fbe37a84a3a.png)

第二种是编译执行。采取这种方式时，也需要先将源代码转换为中间代码，然后我们的编译器再将中间代码编译成机器代码。通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序时直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213576784-ca3e5768-ad2e-41d3-bc4b-e4b30de479d2.png)



执行JavaScript语言有好几种虚拟机（引擎），v8只是其中的一种。



## V8是怎么执行JavaScript代码的？

V8在执行JavaScript代码时采用的是混合编译执行和解释执行这两种手段，称为JIT（Just In Time）技术。

解释执行的启动速度快执行速度慢，而编辑执行是启动速度慢执行速度快，所以JIT结合这两种方法的有点。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637213779552-5766ec86-79bf-4fc1-86fb-4545e1f00f49.png)



首先，在V8启动执行JavaScript之前，需要准备JavaScript执行时所需要的一些基础环境，包括“堆空间”、“栈空间”、“全局执行上下文”、“全局作用域”、“消息循环系统”、“内置函数”等，这些内容都是在执行JavaScript过程中需要用到的。

比如：

- 全局执行上下文包含了执行过程中的全局信息，如内置函数、全局变量等信息；
- 全局作用域包含了一些全局变量，在执行过程中的数据都需要存放在内存中；

- 还需要准备堆栈管理需要的堆栈结构。
- 初始化消息循环系统，不断接收信息并决策如何处理消息。



1. V8会接收到要执行的JavaScript源代码字符串，此时V8不能直接解读这些源码字符串，需要结构化这些字符串。

2. 源码结构化之后，生成抽象语法树（AST），生成AST的同时，还会生成相关的作用域。

3. 有了AST和作用域之后，接下来开始生成字节码，字节码是介于AST和机器代码的中间代码。

4. 解析器按照顺序解释执行字节码，并输出执行结构。

5. 监控解释器会把重复多次执行的代码标记为热点代码。

6. 当某段代码被标记为热点代码后，V8就会将这段字节码丢给优化编译器，优化编译器在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作。在之后再执行这段代码时，V8会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。

7. 当对象结构被动态修改时，优化后的代码就会被优化编译器反优化，恢复到解释器中解释执行。



# JavaScript函数的特点

## 函数的本质

函数是一种特殊的对象，它和对象一样可以拥有属性和值，但是函数和普通对象不同的是函数可以被调用。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637324373389-7256d7d2-83c9-4043-bbec-ad714f4a5ecb.png)

在V8中，会为函数增加两个隐藏属性。`name`和`code`。

`name`属性的值就是函数名称，默认值是`anonymous`，表示该函数对象没有被设置名称。

`code`属性，表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8便会从函数对象中取出`code`属性值，也就是函数代码，然后再解释执行这段函数代码。



如果某个编程语言的函数可以和它的数据类型做一样的事情，我们就把这个语言中的函数称为`一等公民`。

> 通常，如果一个值它可以作为一个参数传递，可以被函数返回，可以被存储在变量中，那它就被称为一等公民。



# V8采用了哪些策略提升了对象属性的访问速度

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637416143371-2e604d44-9c1b-4a13-981d-b402dc6b8332.png)

## 常规属性（properties）和排序属性（elements）

```jsx
var obj = {b: 10, a: 20};
obj[10] = 30;
obj[1] = 40;

for (key in obj) {
	console.log(key, obj[key]);
}
// 1, 40
// 10, 30
// b, 10
// a, 20
```

ECMAScript规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。

对象中的数字属性称为排序属性，字符串属性称为常规属性。

在V8内部，为了有效地提高存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。

当执行索引操作时，V8会先从排序属性中按照顺序读取所有的元素，然后再从常规属性中读取所有的元素，这样就完成一次索引操作。



## 快属性和慢属性

对属性进行区分简化了程序的复杂度，但是却在查找元素时，多了一步操作。基于此原因，V8采取了一个权衡的策略以加快查找属性的效率，将部分常规属性直接存储到对象本身，这样的属性称为`对象内属性（in-object properties）`

不过对象内属性的数量是固定的，默认是**10个**，如果添加的属性超过了对象分配的空间，则它们将被保存在常规属性存储中。虽然属性存储多了一层间接层，但可以自有地扩容。

将保存在线性数据结构中的属性称为`快属性`，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。



如果一个对象的属性过多时，V8就会采取另外一种存储策略`慢属性`，但慢属性的对象内部会有独立的非线性结构作为属性存储容器，所有的属性元信息不再是线性存储的，而是直接保存到属性字典中。

```javascript
function Foo(len) {
  new Array(len).fill(1).forEach((item, index) => {
    this[index] = 'elements' + index;
  });
  new Array(len).fill(1).forEach((item, index) => {
    this[`index_${index}`] = 'properties' + index;
  });
}
const foo = new Foo(10);
const foo1 = new Foo(20);
const foo2 = new Foo(100);
```

**当只创建了十个常规属性时，10个常规属性作为对象内属性，存放在foo函数内部，10个排序属性存放在elements中。**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417036090-a63269dd-7737-4d7a-a318-77b34552c184.png)

**当创建20常规属性时，10个属性直接存放在foo1的对象内；10个常规属性以线性数据结构存放在properties属性内；20个排序属性存放在elements属性内；**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417147206-7993ce70-b77e-4cb6-9234-e196ee90918b.png)

**当创建100个常规属性时，10个属性存放在foo2对象内部；90个常规属性以非线性字段的数据结构存放在properties属性中；100个排序属性存放在elements属性里面；**

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417262769-b4f08eca-b9b7-4452-bdd4-0fc38ad6d3cd.png)



```javascript
function Foo() {};
const obj = new Foo()
obj['name'] = 'wang';
obj['age'] = 20;
obj[1] = 'yu';
obj[2] = 'yu';
obj[1000] = 'yu';
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637417915546-06538650-2b9d-4cc5-9bfa-2d559ce0a835.png)

element中的数据存放如果是稀疏数组的情况下（下标从2跨越到1000），为了节省空间，稀疏数组会转换为哈希存储的方式，而不再是用一个完整的数组描述这块空间的存储。



**为什么有序的线性结构查找起来要比无序的非线性结构的查找耗时要短？**

> 因为线性结构的查找是线性结构长度次的简单位运算，而非线性结构要先经过哈希算法计算。这是一个复杂计算。



# 函数表达式

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637502566948-16fb9167-1100-4035-9736-4b44d53bcacf.png)



V8在处理函数声明的时候会存在变量提升，在编译阶段，foo函数对象就被V8存放在内存中的堆空间（作用域）中，所以在执行阶段，V8就能获取到所有定义的函数。

而如果是一个普通变量，变量提升后会先赋值为undefined。



表达式就是表示值的句子，语句是操作值的式子。

比如

> x = 5

就是一个表示式，因为执行代码，会返回一个值。

而

> var x

就是一个语句，执行该语句时，V8并不会返回任何值给你。

所以函数声明也是一个语句。

```javascript
var x = 5;

// 这段代码在V8眼中是两个阶段
var x = undefined;
x = 5;
```

其中`var x`是在编译阶段完成的，也就是变量提升阶段，而`x = 5`是表达式，所有的表达式都是在执行阶段完成的。函数也是一个对象，所有在编译阶段，V8就会将整个函数对象提升到作用域中，并不是给该函数名称赋值为undefined。

```javascript
foo()
var foo = function () {
	console.log(1);
}

// 这段代码在V8眼中是两个阶段
var foo = undefined;
foo = function () {
	console.log(1);
}
```

函数表达式是表达式，所以是在执行阶段才赋值的。



**立即调用的函数表达式（IIFE）**

JavaScript中有一个圆括号运算符，圆括号里可以放一个表达式。

```javascript
(function () {
	console.log(1);
})
```

如果在小括号中定义一个函数，那么V8就会把这个函数看做是函数表达式，执行时它会返回一个函数对象，可以直接调用。

因为函数立即表达式是立即执行的，所有将一个函数立即表达式赋值给一个变量时，不是存储函数本身，而是存储函数执行后的结果。

```javascript
var a = (function () {
	return 1;
});
console.log(a) // 1
```



# 原型链继承

每一个JavaScript对象都有一个原型属性（`__proto__`），该属性指向了该对象的原型对象，查找属性的时候，JavaScript虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637541243537-cb264bc0-3805-4d09-b6ea-29c420c1c22b.png)

```javascript
function DogFactory(type, color) {
	this.type = type;
  this.color = color;
}
var dog = new DogFactory('Dog', 'Black');

console.log(dog.__proto__ === DogFactory.prototype) // true
console.log(DogFactory.__proto__ === Function.prototype) // true
console.log(DogFactory.prototype.__proto__ === Object.prototype) // true
```

DogFactory 是 Function构造函数的一个实例，所有DogFactory的远行属性__proto__ 指向Function的prototype，而dog是DogFactory的实例，所以`dog.__proto__ === DogFactory.prototype`。



V8执行这段代码时

```javascript
var dpg = {};
dog.__proto__ = DogFactory.prototype;
DogFactory.call(dof, 'Dog', 'Black');
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637541630395-cd141541-c396-4cf0-9946-094f43f8de59.png)

- 首先，创建一个空白对象dog；
- 将DogFactory的prototype属性设置为dog的原型对象；

- 最后，再使用dog来调用DogFactory，这时候DogFactory函数中的this就指向对象dog，然后在DogFactory函数中，利用this对对象dog执行属性填充操作，最终就创建了对象dog；



每个函数对象都有一个公开的prototype属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建的对象的原型对象就指向了该函数的prototype属性。正常调用函数时，prototype属性不起作用。



# 作用域链

> 作用域链就是将一个个作用域串起来，实现变量查找的路径。讨论作用域链，实际就是在讨论按照什么路径查找变量的问题。

作用域就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。

全局作用域是在V8启动过程中就创建了，且一直保存在内存中不会被销毁的，直至V8退出。而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了。

```js
var type = 'a1';
var name = 'a';
function foo() {
  	var name = 'c';
  	console.log(name); // c
    console.log(type); // a1
}
function bar() {
    var type = 'b1';
  	var name = 'b';
    foo();
}
bar();
```

 

+ 这段代码，当V8启动时，会创建全局作用域，全局作用域包含了this、window等变量，还有一些全局的web API接口。

+ V8启动后，执行代码。

+ 首先预编译代码，在编译过程中会将顶层（全局）定义的变量和声明的函数都添加到全局作用域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559652650-ed11f458-bc99-499f-998b-c7527f0c79c4.png)

+ 全局作用域创建完之后，进入执行状态。

+ 当V8执行bar函数的时候，同样需要经过编译和执行两个阶段。在编译阶段，V8会为bar函数创建函数作用域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559748458-0d77eba0-604a-4ca6-a5bd-12e2f6a6c5d3.png)

+ 然后在bar中调用foo函数，又会进入foo函数的编译和执行阶段。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637559785527-53d9e451-becb-4927-83f0-c1d495560163.png)



JavaScript是基于词法作用域的，词法作用域是指，查找作用域的顺序是按照函数定义时的位置来决定的。bar和foo函数的外部代码都是全局代码，所以无论在bar函数中查找变量还是在foo函数中查找变量，其查找顺序都是`当前作用域 -> 全局作用域`这个路径。



词法作用域因为是根据函数在代码中的位置来确定的，作用域在声明函数的时候已经确定好了，所以词法作用域也称为`静态作用域`。

相对的 动态作用域只关心函数是在何处调用的，不关心函数是在何处声明的。

作用域链式基于调用栈的，而不是基于函数定义的位置的。



# 类型转换

1 + '2' 为什么等于 '12' ？

类型系统：用于定义如何将编程语言中的述职和表达式归类为许多不同的类型，如何操作这些类型，这些类型如何相互作用。

## V8是如何执行加法操作的？

V8会提供一个ToPrimitive方法，其作用是将a和b转换为原生数据类型

- 先检测该对象中是否存在valueOf方法，如果有并返回了原始类型，那么久使用该值进行强制类型转换；
- 如果valueOf没有返回原始类型，那么就使用toString方法的返回值；

- 如果valueOf和toString两个方法都不返回基本类型值，便会触发一个TypeError的错误；

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637584566447-41e337df-6534-4b98-9cba-4f0b18c0102e.png)



当执行1 + '2'时，因为这是两个原始值相加，其中一项为字符串，那么V8默认将另一个值也转为字符串。相当于

```jsx
Number(1).toString() + '2';
```



# JavaScript运行时环境

## 宿主环境

V8的宿主环境可以是浏览器、NodeJS或其他开发环境。提供了V8执行JavaScript时所需要的基本功能部件。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637679569272-465af41a-d748-4e17-adb4-757bfc67e48e.png)



## 堆栈空间

栈空间主要是用来管理JavaScript函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放到栈上，比如原生类型、应用到的对象的地址、函数的执行状态、this值等都会存在于栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。

栈空间的最大的特点是空间连续，所有在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8对栈空间的大小做了限制，如果函数调用层过深，那么V8就可能抛出栈溢出的错误。

Maximum call stack size exceeded



如果有一些占用内存比较大的数据，或者不需要存储在连续空间中的数据，可以使用堆空间。

堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，函数、数组、浏览器内置对象，都存在堆空间中。



## 全局执行上下文和全局作用域

当V8开始执行一段可执行代码时，会生成一个执行上下文。V8用执行上下文来维护执行当前代码所需要的变量声明、this指向等。

执行上下文中主要包含了三部分，变量环境、词法环境、和this关键字。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637680353273-f37636b4-d188-4b20-be3d-5f6815ba9e37.png)

全局执行上下文在V8的生命周期内是不会被销毁的，它会一直保存在堆中，这样当下次再需要使用函数或全局变量时，就不需要重新创建了。



当V8调用了一个函数时，就会进入函数的执行上下文，这时候全局执行上下文和当前的函数执行上下文就形成了一个栈接口。



# 函数调用与内存布局



```js
// 栈溢出
function foo() {
	foo();
}
foo();

// 正常执行
function foo() {
	setTimeout(foo, 0);
}
foo();

// 不会栈溢出，但会导致整个页面卡住
function foo() {
	return Promise.resolve().then(foo);
}
foo();
```

这三段代码的底层执行逻辑分别是：

- 第一段代码是在同一个任务中重复调用嵌套的foo函数；
- 第二段代码是使用setTimeout让foo函数在不同的任务中执行；

- 第三段代码是在同一个任务中执行foo函数，但是却不是嵌套执行。

三种不同的执行方式，V8执行时的内存布局是不一样的。

## 为什么使用栈结构来管理函数调用？

### 函数的特点：

+ 第一个特点是函数可以被调用，你可以在一个函数中调用另外一个函数，当函数调用发生时，执行代码的控制器将从富含鼠转移到子函数，子函数执行结束之后，又会将代码执行控制器返还给父函数。

+ 第二个特点是函数具有作用域机制，所谓作用域机制，是指函数在执行的时候可以将定义在函数内部的变量和外部环境隔离，在函数内部定义的变量我们也称为临时变量，临时变量只能在该函数中被访问，外部函数通常无权访问，当函数执行结束之后，存放在内存中的临时变量也随之被销毁。

**函数调用者的生命周期总是长于被调用者（后进），并且被调用者的生命周期总是先于调用者声明周期结束（先出）**

函数作用域在函数执行完成之后，会将其内部数据销毁掉。站在函数资源分配和回收角度来看，**被调用函数的资源分配总是晚于调用函数（后进），而资源函数的释放总是先于调用函数（先出）**。

函数的生命周期和资源分配和栈一样符合后进先出的策略，所以用栈来管理函数调用。



## 栈如何管理函数调用

当执行函数内子函数的调用结束后，会将栈的状态恢复为当前函数上次执行时的状态，这个过程叫恢复现场。寄存器中会保存一个永远执行当前栈顶的指针，栈顶指针的作用就是告诉你应该往哪个位置添加新元素，这个指针通常存放在esp寄存器中。

**栈帧中保存了该函数的返回地址和局部变量**。在JavaScript中，如果调用一个新函数，那么V8会为该函数创建栈帧，等函数执行结束之后，销毁该栈帧，而栈结构的容量是固定的，所以如果重复嵌套执行一个函数，那么就会导致栈溢出。

递归的时候，因为没有结束条件，就会导致每次都有一个新的执行上下文加入到调用栈中，却不会有出栈的情况，这样就很容易超出栈的最大容量，导致栈溢出报错。



# V8是如何实现闭包的？



在编译JavaScript代码的过程中，V8并不会一次性将所有的JavaScript解析为中间代码。

+ 首先，如果一次解析和编译所有的JavaScript代码，过多的代码会增加编译时间，这会严重影响到首次执行JavaScript代码的熟读，让用户感觉到卡顿。

+ 其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有JavaScript代码，那么这些中间代码和机器代码将会一直占用内存。

现在的所有JavaScript虚拟机都实现了惰性解析。

> 解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成AST和字节码，而仅仅生成顶层代码的AST和字节码。



```javascript
function foo(a, b) {
	var d = 100;
  var f = 10;
  return d + f + a + b;
}
var a = 1;
var c = 4;
foo(1, 5);
```

当这段代码交给V8处理时，V8会至上而下解析这段代码，在解析时，V8只是把foo函数解析为函数对象，但是并没有解析和编译函数内部的代码，所有不会为foo函数的内部代码生成抽象语法树。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637933273160-032cced5-9843-4dc7-be55-a83333553bf7.png)

而 a、c等其他顶层代码会生成抽象语法树。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1637933448857-cb474f8d-14f8-44a4-afff-1fc46ca9dcb0.png)

## JavaScript闭包的三个特性

- JavaScript语言允许在函数内部定义新的函数
- 可以在内部函数中访问父函数中定义的变量

- 因为函数是一等公民，所有函数可以作为返回值



## 闭包给惰性解析带来的问题

```javascript
function foo() {
	var d = 20;
  return function inner(a, b) {
  	const c = a + b = d;
    return c;
  }
}
const f = foo();
```

当调用foo函数时，foo函数会将它的内部函数inner返回给全局变量f；

然后foo函数执行结束，执行上下文被V8销毁了；

虽然foo函数的执行上下文被销毁了，但是依然存活的inner函数引用了foo函数作用域中的变量d；



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638085255433-82e63733-4746-4109-b43e-9e756fd28ff8.png)

执行全局代码时，V8会将全局执行上下文压入到调用栈中，然后进入执行foo函数的调用过程，这时候V8会为foo函数创建执行上下文，执行上下文中包括了变量d，然后将foo函数的执行上下文压入栈中，foo函数执行结束之后，foo函数执行上下文从栈中弹出，这时候foo执行上下文中的变量d也随之销毁。

但是由于inner函数被保存到全局变量中，所以inner函数依然存在，最关键的地方在于inner函数使用了foo函数中的变量d，按照正常执行流程，变量d在foo函数执行结束之后就被销毁了。但是虽然foo函数的执行上下文被销毁了，但是inner函数引用的foo函数中的变量却不能被销毁，那么这个时候V8就要做特殊处理了，需要保证d变量不随着foo函数的执行结束而销毁。



这个时候需要V8的预解析器来处理这种情况。当解析顶层代码时，遇到一个函数，那么预解析器不会直接跳过该函数，而是对该函数做一次快速的预解析，其目的为：

- 判断当前函数是不是存在一些语法上的错误。
- 检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量赋值到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。



# 二进制机器码究竟是如何被CPU执行的？

V8在执行代码时需要先将JavaScript编译成字节码，然后再解释执行字节码，或者将需要优化的字节码编译成二进制，并直接执行二进制代码。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638088681668-ce836559-b15c-428f-ad49-2d3b55b4270e.png)

计算机硬件结构

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638088745901-758b286d-cc6c-46d0-855f-a18e33be914e.png)



首先，在程序执行之前，我们的程序要被装进内存。而CPU可以通过指定内存地址，从内存中读取数据，或者往内存中写入数据，有了内存地址，CPU和内存就可以有序的交互。

内存中的每个存储空间都有其对应的独一无二的地址。在内存中，每个存放字节的空间都有其唯一的地址，而且地址是按照顺序排放的。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638088852924-5e542597-561e-4a22-9a6a-c35f60a35564.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638088927606-ef492001-143c-4f33-8df9-b44ce909d1a3.png)



一旦二进制代码被装载进内存，CPU就可以从内存中取出一条指令，然后分析该指令，最后执行该指令。

把取出指令、分析指令、执行指令这三个过程称为一个CPU始终周期。CPU是一直在执行指令到，重复这个时钟周期，直到所有的指令执行完成。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638089052735-1eb142ed-a8ab-470c-991e-db4ebc7b176c.png)

CPU中有一个PC寄存起，保存了将要执行的指令地址。在下一个时钟周期开始之前，CPU会根据PC寄存器中的地址，从内存中取出指令。

PC寄存器中的指令取出来之后，将下一条指令的地址更新到PC寄存器中，分析取出的指令，识别、获取等操作后，执行指令。



通用寄存器是CPU中用来存放数据的设备，不同处理器中寄存器的个数也不一样，之所以要通用寄存器，是因为CPU访问内存的速度很慢，所有CPU需要在内部添加一些存储设备。

通用寄存器容量小，读写速度快，内存容量大，读写速度慢。

通用寄存器通常用来存放数据或者内存中某块数据的地址。



# 如何在内存中快速查找对象属性

## 为什么静态语言的效率更高？

JavaScript在运行时，对象的属性是可以被修改的，所以当V8使用了一个对象时，它不知道该对象中是否存在某个属性，也不知道属性相对于对象的偏移量是多少。当JavaScript中要查询对象属性时，V8会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。

静态语言C++在声明一个对象之前需要定义该对象的结构，我们也可以称为形状，我们可以只用这个形状来定义具体的对象。C++代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中，形状是无法被改变的。当在C++中使用对象时，直接去内存地址中取出该内容即可，没有任何中间的查找环节。

```cpp
struct Point {
	int x;
    int y;
}
Point start;
start.x = 100;
start.y = 200;
```

V8将这种静态语言的特性引入到引擎中。

V8在运行JavaScript的过程中，会假设JavaScript中的对象是静态的，V8对每个对象做两点假设：

- 对象创建好了之后就不会添加新的属性；
- 对象创建好了之后也不会删除属性；

实现上，V8会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括：

- 对象中所包含的所有的属性；
- 每种类型相对于对象的偏移量；

有了隐藏类之后，当V8访问某个对象中的某个属性是，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8就可以直接去内存中取出对应的属性值。

```jsx
let point = {x: 100, y: 200};
```

当V8执行到这里是，会先为point对象创建一个隐藏类（map），每个对象都有一个map的属性，其值指向内存中的隐藏类。**point对象的第一个属性的指针指向map地址**。

隐藏类描述了对象的属性布局，包括了属性名称和每个属性所对应的偏移量，比如point对象的隐藏类就包括了x和y属性，x的偏移量是4，y的偏移量是8。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638187450383-c9b23950-4d66-4a6e-83d0-977f5f03bc89.png)



map不是point对象本身。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638187474123-1f151309-6188-46f5-a4c7-baf4feb93553.png)

多个相同形状的对象可以共用一个隐藏类。好处是：

- 减少隐藏类的创建次数，也间接加速了代码的执行速度；
- 减少了隐藏类的存储空间；

如何判断对象形状相同？相同的属性名称和属性个数；

```cpp
const point = {x: 100, y: 200};
const point2 = {x: 1, y: 2};
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638187631207-9971451b-aeb7-4460-88f5-37519c54be2a.png)

如果对象的形状发生了改变，那么V8会重建一个新的隐藏类给该对象。

所以日常开发中需要注意几点：

- 使用字面量初始化时，要保证属性的顺序是一致的；
- 尽量使用字面量一次性初始化完整对象属性；

- 尽量避免使用delete方法



# 通过内联缓存提升函数执行效率

```javascript
function loadX(o) {
	return o.x;
}
var o = {x: 1, y: 3};
var o1 = {x: 3, y: 6};
for (var i = 0; i < 90000;i++) {
	loadX(o);
  loadX(o1);
}
```

当一个函数被反腐执行时，V8会想办法压缩这个查找过程，以提升对象的查找效率，这个策略就是`内联缓存（Inline Cache）`，简称IC。

IC的工作原理比较简单，就是在V8执行函数的过程中，会观察函数中一些调用点上的关键的中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8就可以直接利用这些中间数据，节省了再次获取这些数据的过程。



IC会为每个函数维护一个**`反馈向量（FeedBack Vector）`**，反馈向量记录了函数在执行过程中的一些关键的中间数据。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638233135096-cc3bf3ac-1260-48b2-a2c3-93c44e3cb38b.png)

反馈向量是一个表结构，它由很多项组成，每一项称为一个`插槽（Slot）`，V8会依次将执行loadX函数的中间数据写入到反馈向量的插槽中。



当V8执行loadX函数时，会判断return o.x是`调用点（CallSite）`，因为它们使用了对象和属性，那么V8会在loadX函数的反馈向量中为每个调用点分配一个插槽。

每个插槽中包括了插槽的缩影、类型、状态和隐藏类的地址，还有属性的偏移量。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638233325328-8bb292cf-0b74-41ad-b63e-bbfd770f41a8.png)



插槽类型包括访问对象属性值的LOAD类型、赋值存储STORE类型和函数调用CALL类型。



当传入loadX函数的对象形状不同时，就会存储多个隐藏类和偏移量，之后的对象如果被执行就会和前面的每个隐藏类进行对比，比较耗时。

- 如果一个插槽中只包含1个隐藏类，那么称为`单态`；
- 如果一个插槽中包含了2 - 4个隐藏类，那么称为`多态`；

- 如果一个插槽中超过了4个隐藏类，那么称为`超态`；



插槽中的隐藏类采用线性结构存储，如果超过了4个，就会采用hash表的结构来存储。所以应该尽量保持单态。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638233784537-1ccbd683-ecf3-4d10-bda1-fbb5bfcc42f7.png)



# V8是如何实现回调函数的

回调函数区别于普通函数的是它的调用方式，只有当某个函数被作为参数，传递给另一个函数，然后该函数在函数内部被调用，才称为回调函数。

回调函数有两种不同的形式，同步回调和异步回调。同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的。

```javascript
// 同步回调
var arr = [1, 2, 3];
function handlerArray(item, index) {
	console.log(item);
}
arr.forEach(handlerArray);

// 异步回调
function foo() {console.log(1)};
setTimeout(foo, 3000);
```

## UI线程的宏观架构

早起的页面是运行在一个单独的UI线程中的，所以要在页面中引入JavaScript，那么JavaScript也必须要运行在和页面相同的线程上，这样才能方便使用JavaScript来操纵DOM，所以，JavaScript就被设计成了运行在UI线程中。

UI线程，是指运行窗口的线程，当你运行一个窗口时，无论该页面是在哪个窗口系统，都需要处理各种事件，比如绘制页面、鼠标点击、移动、拖拽、资源下载、文件读写等事件。

在页面线程中，当一个事件被触发时，系统需要将该事件提交给UI线程来处理。但是UI线程并不能每次都能立即响应和处理事件，可能页面线程还在处理上一个事件。

对此，UI线程提供了一个消息队列，并将待执行的事件添加到消息队形，然后UI线程会不断循环地从消息队列中取出时间、执行时间。把UI线程每次从消息对象中取出时间、执行时间的过程称为一个任务。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638272384969-6225413f-c36c-412d-9b78-c910472f5704.png)



主线程会不间断地从消息队列中取出新的任务，执行新的任务。

XMLHttpRequest是用来下载网络资源的，而网络资源并不适合在主线程上执行，因为下载任务比较消耗时间，所有当有下载任务的时候，主线程会将其分配给网络线程，让其在网络线程上执行下载过程，这样就不会影响到主线程的执行了。![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638272521409-9c4ba9f4-b7f9-4957-b87a-be93a0e058fb.png)



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638272557452-1db5654a-2c90-443b-b848-e77001d455ff.png)



# V8是如何实现微任务的

> 宏任务：指消息队列中的等待被主线程执行的事件。

> 微任务：异步执行的函数，执行时机在主函数执行结束之后，当前宏任务结束之前。

引入微任务是因为主线程执行消息队列中宏任务的时间颗粒度太粗，无法胜任一些对精度和实时性要求较高的场景，微任务可以在实时性和效率之间做一个有效的权衡。

微任务包括：**协程、promise、generator、await/async、消息队列、事件循环、UI主线程、堆和栈**



递归导致的栈溢出

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638336728291-3fe45ced-b004-4660-8f2a-b144ae92f09c.png)



setTimeout可以解决栈溢出的问题，setTimeout的本质是将同步函数调用改成异步函数调用，异步调用将foo封装成事件，并将其添加到消息队列中，然后主线程再按照一定规则循环地从消息队列中读取下一个任务。

```javascript
function foo() {
	setTimeout(foo, 0);
}
foo();
```

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638336901691-85819835-5a29-404f-a884-df24f7736d02.png)

当V8执行foo函数中的setTimeout的时候，setTimeout会将foo函数封装成一个新的宏任务，并将其添加到任务队列中。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638336958628-256907d0-768e-41cd-a268-833a68d02ee2.png)

当一个宏任务执行结束之后，忙碌的主线程依然不会闲下来，它会一直重复这个取宏任务、执行宏任务的过程。setTimeout封装的回调宏任务，也会在某一时刻取出并执行。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638336973396-75ffd7f8-7df8-436d-920d-363aac214da1.png)

因为foo函数不是在当前的父函数内部被执行，所有不会对当前宏的调用栈造成栈溢出的问题。



宏任务的问题在于如果前面的宏任务的执行时间过久，会影响到后面的宏任务的执行，而且时间不可控。

这是就需要引入微任务， V8会为每个宏任务维护一个微任务队列。当V8执行一段JavaScript时，会为这段代码创建一个环境对象，微任务队列就是存放在该环境对象中的。

触发的微任务不会在当前的函数中被执行，所以执行微任务时，不会导致栈的无限扩张。

微任务会在当前任务执行结束之前被执行，所以微任务执行结束之前，消息队列中的其他任务是不可能被执行的。



# V8是如何实现async/await的

async是一个通过异步执行并隐式返回Promise作为结果的函数。

await后面可以是一个普通表达式，也可以是一个Promise对象的表达式。

如果await等待的是一个Promise对象，它就会暂停执行生成器函数，直到Promise对象的状态变成resolve，才会恢复执行，然后得到resolve的值，作为await表达式的运算结果。

使用async声明的函数在执行时，是一个单独的线程，可以通过await来暂停线程，可以通过resolve来恢复线程。

如果await后面是一个普通表达式，那么V8会隐式的将其转换为resolve表达式。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638366124216-14059352-b3b0-4bc3-afe5-4dbaccc60857.png)



# V8垃圾回收机制

## 垃圾回收实现步骤

第一步，通过GC Root标记空间中活动对象和非活动对象。

目前V8采用的可访问性算法来判断堆中的对象是否是活动对象。

通过GC Root遍历到的对象，就认为该对象是可访问的，那么必须保证这些对象应该在内存中保留，也称为可访问的对象为活动对象。

通过GC Root没有遍历到的对象，则是不可访问的，那么不可访问的对象就可能被回收，我们称不可访问的对象为非活动对象。

GC Root可以是window对象、DOM树、栈上的变量等。



第二步，回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。

第三步，做内存整理。频繁回收对象后，会存在内存碎片。当内存中出现大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况。不过有的垃圾回收器不会产生内存碎片。



V8采用了两个垃圾回收器：**`主垃圾回收器-Major GC`** 和**`副垃圾回收器-Minor GC（Scavenger）`**。V8采用两个垃圾回收器，主要是受到了代际假说的影响。

代际假说是垃圾回收领域中一个重要的术语，它有两个特点：

+ 大部分对象在内存中存活时间很短，比如函数内部声明等

+ 不死的对象，会活的更久，比如全局的window、DOM等对象。



在V8中，会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。

新生代通常只支持1 - 8M的容量，而老生代支持的容量较多。

## 副垃圾回收器

副垃圾回收器主要负责新生代的垃圾回收。通常情况下，大多数小的对象都会被费配到新生代，这个区域虽然不大，但是垃圾回收比较频繁。

新生代中的垃圾数据用Scavenge算法来处理。把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638367730257-430f1908-b5e7-474f-be1f-d83f5aa7247e.png)



新加入的对象都会被存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成后，就进入垃圾清理阶段。副垃圾回收器会把这些存活的对象复制到空闲区域内，同时它还会把这些对象有序地排列起来。所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638367888112-e004df16-890d-40b3-8e31-9b955742c32f.png)

完成复制后，对象区域和空闲区域进行角色翻转，就是把原来的对象区域变为空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时，这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

不过将存活对象从对象区域复制到空闲区域，赋值操作需要时间成本，所有为了执行效率，一般新生代的空间会被设置的比较小。

同时，在垃圾回收的同时，会将那些经历过两次垃圾回收依然还存活的对象移动到老生代中。



## 主垃圾回收器

主垃圾回收器主要负责老生代的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。因此，老生代中的对象有两个特点：

+ 一个是对象占用空间大；

+ 另一个是对象存活时间长；

主垃圾回收器采用**`标记-清除（Mark-Sweep）`**的算法进行垃圾回收

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

接下来是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据清理掉。

主垃圾回收器的操作同样会产生内存碎片，这是又引入了另一种算法-- **`标记-整理（Mark-Compact）`**。

这个算法将标记的可回收对象都向一端移动，然后直接清掉这一端之外的内存。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638368564703-319fa3ff-059b-4e85-9b77-f8fb81fa1ab3.png)



# V8如何提高垃圾回收器的执行效率



JavaScript是运行在主线程上的，因此，一旦开始执行垃圾回收算法，就需要将正在执行的JavaScript脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为称为全停顿。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638369742446-029823c5-7ce9-4291-b32f-9b1b667fa316.png)

如果一个页面因为垃圾回收器在工作造成页面卡顿，用户体验不佳。

现有解决垃圾回收效率的技术观点：

将一个完整的垃圾回收的任务拆分成多个小的任务。这样就消灭了单个长的垃圾回收任务。

将标记对象、移动对象等任务转移到后台线程进行，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅。



## 并行回收

主线程在执行垃圾回收的任务时，开启多个协助线程，同时执行同样的回收工作。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638370104717-efa0229b-d1cf-4180-8a22-cc66401b6fc3.png)



## 增量回收

垃圾收集器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638370176981-25bce017-487b-40bc-88b5-d755986eb3fb.png)



增量标记的算法，需要实现：

垃圾回收可以被随时暂停和重启，暂停时需要保存当时的扫描结果，等下一波垃圾回收来了之后，才能继续启动。

在暂停期间，被标记好的垃圾数据如果被JavaScript代码修改了，那么垃圾会搜狐器需要能够正确地处理。



## 并发回收

主线程在执行JavaScript的过程中，辅助线程能够在后台完成执行垃圾会搜狐的操作。

![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638370595271-ab3d771d-4165-4a08-88f6-124dc7235553.png)

并发回收的技术实现是最难的一种

+ 首先，当主线程执行JavaScript时，堆中的内容随时都有可能发生变化，从而使得辅助线程之前做的工作完全失效。

+ 其次，主线程和辅助线程极有可能在同一时间去更改同一个对象，这就需要额外实现读写锁的一些功能了。



![img](https://cdn.nlark.com/yuque/0/2021/png/21510703/1638370862883-f5286437-2ae6-468f-9a4c-52da1738cc35.png)

V8的主垃圾回收器融合了这三种机制。

+ 首先主垃圾回收器主要使用并发标记，我们可以看到，在主线程执行JavaScript，辅助线程就开始执行标记操作，所以说标记是在辅助线程中完成的。

+ 标记完成之后，再执行并行清理操作。主线程在执行清理操作时，多个辅助线程也在执行清理操作。

+ 另外，主垃圾回收器还采用了增量标记的方式，清理的任务会穿插在各种JavaScript任务之间执行。

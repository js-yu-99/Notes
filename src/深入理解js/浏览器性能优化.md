## CRP

Critical Rendering Path 关键渲染路径

+ 从服务器基于网络请求回来的数据是16进制的文件流，
+ 浏览器把文件流解析成字符串（词法解析）
+ 把字符串根据w3c规则识别成dom节点
+ 根据节点的层级结构生成DOM树



进程：一般指一个程序（浏览器打开一个页面，就相当于开启了一个进程）。

<span style="color: red">同一域名下，在A页面内跳转打开B页面，此时，A、B页面共用A页面的进程</span>

线程：进程中具体去执行事物的东西，一个线程只能同时干一件事情。

一个进程有一个或多个进程。

同步编程：一般指进程中只有一个线程去处理事情。

异步编程：进程中有多个线程。 单线程异步编程（JavaScript）、多线程异步编程

浏览器是多个进程/线程的

+ GUI渲染线程：渲染页面

+ JS引擎线程：渲染JS

+ HTTP网络线程：可以开辟多个，从服务器获取资源和数据的。

+ 定时器监听线程：监听定时器

+ DOM监听线程

......



渲染页面过程中

+ 遇到style内嵌样式，GUI线程直接渲染。
  + 如果CSS代码量比较少，直接内嵌即可。拉去html的时候，css也直接回来了，直接渲染。
  + 如果css代码比较多，还用内嵌的方式，一方面会影响html的拉去速度，也不利于代码的维护，还是用外链的方式比较好。
+ 遇到link，浏览器开辟一个http网络请求线程请求文件信息，同时GUI会继续往下渲染。
  + 浏览器同时发送的http请求次数是有数量限制的（Chrome 5 - 7 个）
  + 超过最大并发限制的http请求需要排队等待。 HTTP请求是越少越好的
+ 遇到@import，浏览器开辟一个http网络线程请求文件，但是此时GUI会暂停渲染。（导入式样式会阻碍GUI的渲染），当资源请求回来后，GUI才能继续。
+ link一般要放到头部，可以尽早的加载资源



+ 外链的js资源会阻塞GUI的渲染
+ async、defer
  + async 请求js资源是异步的，单独开辟http请求，此时GUI继续渲染，一但当js请求回来，会立即暂停GUI处理，渲染JS
  + defer 和link是类似的，不会阻碍GUI渲染，当GUI渲染完，才会把请求回来的JS去渲染
+ async 没有顺序，谁先请求完谁先执行。defer 会等待GUI渲染完成并且所有defer 的资源都请求回来再按照顺序执行。
+ JS资源最好都放到底部，如果不能，需要加上async/defer。
+ img、audio、video 资源请求和link类似



DOM Tree  -> CSSOM Tree -> Render Tree -> Layout布局计算（回流 | 重排 reflow） -> Paint绘制（重绘） -> display

JS引擎线程一直被占用会导致页面无法渲染

```html
<body>
	<div id="box">1111</div>
  <script>
    while (true) {}
  </script>
</body>
```

页面第一次渲染  必然会引发一次回流和重绘

如果改变了元素的位置和大小，浏览器需要重新计算元素在视口中的位置和大小信息，重新计算的过程就是回流，一但发生了回流，就一定会触发重绘。

如果只是简单的颜色等样式改变，只会触发重绘



优化点

标签不要嵌套太深

写css选择器层级不要过长



+ 新版本浏览器存在渲染队列，会自动批量渲染样式。

